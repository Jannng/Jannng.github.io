<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java并发]]></title>
    <url>%2F2019%2F06%2F26%2Fjava%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[从并发编程bug聊起近几年，我们电脑的 CPU，内存和 I/O 设备都在不段的更迭。但是始终这三者之间存在着一个核心的矛盾，这三者之间的速度差异。为了合理的利用 CPU 的高性能，平衡这三者之间的差距，有了一下的解决方法： CPU 增加缓存，以平衡与内存之间的速度差异。 操作系统增加了进程，线程，以分时复用 CPU，进而均衡 CPU 和 I/O 设备之间的速度差异。 编译层程序优化指令执行的次序，使得缓存能够得到更加合理的利用。 而很多并发程序的 Bug 的根源也在这里。 源头之一：缓存导致的可见性问题在单核时代。所有的线程都在一个 CPU 上执行，CPU 缓存和内存的数据一致性很容易解决。所有的线程都操作的是同一个 CPU 的缓存，这对于另一个线程来说是一定可见的。如下图，线程 A 操作了 变量 V 这一操作，线程 B 是可见的。 一个线程对共享变量的修改，其他线程能立刻看见，这个称为可见性。 但是现在，CPU 都是多核，每颗 CPU 都有着自己的缓存，这个时候 CPU 缓存和内存之间的一致性就不是那么好解决的了。每个线程操作在不同的 CPU 缓存上。如下图，线程 A 在自己的 CPU 缓存中修改了共享变量 V。这一操作对于线程 B 而言是不可见的。 下面我们通过一段代码来验证多核场景下可见性的问题。 1234567891011121314151617181920212223public class Visible01 &#123; private long count; private void add10k()&#123; int idx = 10000; while (idx &gt; 0)&#123; count++; idx--; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Visible01 visible = new Visible01(); Thread thr1 = new Thread(() -&gt; visible.add10k()); Thread thr2 = new Thread(() -&gt; visible.add10k()); //启动两个线程 thr1.start(); thr2.start(); //等待两个线程结束 thr1.join(); thr2.join(); System.out.println(visible.count); &#125;&#125; 咋眼看，代码的输出结果应该是 20000 。但是实际上的结果是在 10000 - 20000 之间的随机数。而导致这样的原因就是，假设两个线程时同时启动的，都会将 count = 0 读入到各自的 CPU 缓存中。执行完 count++ 以后，将结果 count = 1 写入到内存中。这样内存中的值就是 1 而不是我们所期待的 2。而之后两个线程都是基于 CPU 缓存中的 count 值来计算，所以导致最后结果小于 20000。 如果循环 10000 次的 count ++ 改成循环 1 亿次，就会发现就结果时更接近 1 亿而不是 2 亿。导致这样的原因就是两个线程不是同时启动的，有一个时间差。 源头之二：进程切换带来的原子性问题由于 I/O 太慢，操作系统提出的进程线程的概念。操作系统允许某个进程执行一小段时间，例如 50 毫秒，每过 50 毫秒操作系统就会进行一次进程切换，这 50 毫秒的时间我们称为 时间片。 Java 中并发程序多时基于多线程的，也就会涉及到任务切换。任务切换的时机大多是在时间片结束的时候，而现在的高级语言中的一条语句往往需要多条 CPU 指令来完成。例如 count += 1，至少需要 3 条 CPU 指令。 首先将 count 从内存加载到 CPU 寄存器 在寄存器中执行 +1 操作 将结果写入内存(缓存机制导可能写入的是 CPU 缓存而不是内存) 任务切换可以发生在任何一条 CPU 指令执行完, 而不是高级语言的一条语句。对于上面 3 条 CPU 指令而言，如果线程 A 在指令 1 执行完以后任务切换，线程 A 和 线程 B 按照下图的序列执行，那么我们就会发现两个线程都执行了 Count += 1 的操作，但是得到的结果不是我们期望的 2 ，而是1。 在我们的潜意识里，Count += 1 是一个不可分割的操作，是一个原子。 我们把一个或多个操作在 CPU 执行的过程中不被中断的特征成为原子性。CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言中的一条语句。 源头之三：编译优化以后带来的有序性问题有序性指的是程序按照先后顺序执行。但是编译器为了优化性能，有时候会改变程序中语句的先后顺序。 在 Java 一个经典的列子就是使用双重锁检查创建单例对象，例如下面的代码，在通过 getInstance() 方法获得单例对象的时候，首先判断对象是否为空，如果为空就锁定对象，再判断一次对象是否为空，如果还是为空，就创建一个对象的实例。 12345678910111213public class Singleton&#123; static Singleton instance; static Singleton getInstance()&#123; if (instance == null)&#123; synchronized (Singleton.class)&#123; if (instacne == null)&#123; instance == new Singleton; &#125; &#125; &#125; return instance; &#125;&#125; 但是这样创建对象还存在一个问题。对于 new 操，我们认为的应该是： 分配一块内存 M 再内存 M 上初始化 Singleton 对象 将 M 的地址赋值给 instance 变量 但是实际上可能编译器优化过后的执行顺序就成了 1-3-2。这样导致的问题就是，假设线程 A 执行了 getInstance() 方法，按照 1-3-2 的顺序 new 一个对象。但是在执行完 3 的时候发生了线程切换。这个时候线程 B 也执行了 getInstance() 方法，这样在第一个判断的时候，线程 B 就判断 instance 是部位空的，直接返回了 instance。但是这个时候的 instance 是还有没初始化的，就可能会出现空指针异常。 Java 内存模型：解决可见性和有序性问题上面我们讲到由于 CPU 和内存的速度差异，会导致 可见性，原子性，有序性 这三个问题，为了解决这些问题，就引出了 Java内存模型（JMM：Java memory Model）。 解决可见性，有序性的问题最直接的方法就是 禁用缓存和编译优化。但是这样就因噎废食了。合理的方案应该是 按需禁用缓存和编译优化。可以认为 Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说这些方法包括 volatile，synchronize，final 这三个关键字和 Happens-Before 原则。 其中：第一是锁 ，锁操作是具备happens-before关系的，解锁操作happens-before之后对同一把锁的加锁操作。实际上 ，在解锁的时候，JVM需要强制刷新缓存，使得当前线程所修改的内存对其他线程可见。第二是volatile字 段，volatile字段可以看成是一种不保证原子性的同步但保证可见性的特性，其性能往往是优于锁操作的 。但是，频繁地访问 volatile 字段也会出现因为不断地强制刷新缓存而影响程序的性能的问题。第三是 final 修饰符，final修饰的实例字段则是涉及到新建对象的发布问题。当一个对象包含final修饰的实例字段时 ，其他线程能够看到已经初始化的final实例字段，这是安全的。 Happens-Before 的意思 前面一个操作的结果对后续操作时可见的。Happens -Before 是具有传递性的。其中的七项原则： 程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作 。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。 管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁 ，而”后面”是指时间上的先后顺序。 volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的”后面”同 样是指时间上的先后顺序。 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作 .线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread.join() 方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。 线程中断规则：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可 以通过 Thread.interrupted()方法检测到是否有中断发生。 对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。 互斥锁：解决原子性问题锁是一种通用的技术方案，Java 语言中提供的 synchronize 关键字，就是一种锁的实现。synchronize 关键字可以修饰方法，也可以修饰代码块，基本上的使用都是这个样子的： 12345678910111213141516171819class Test&#123; // 修饰非静态方法 synchronize void foo()&#123; // 临界区 &#125; // 修饰静态方法 synchronize static void bar()&#123; // 临界区 &#125; // 修饰代码块 Object lock = new Object(); void baz()&#123; synchronize (lock) &#123; // 临界区 &#125; &#125;&#125; 在 Java 中只有修饰代码块的时候，才会显式的锁定一个对象。在修饰静态方法，非静态方法的时候都是隐式的锁定。 当修饰静态方法的时候，锁定的是当前类的 Class 对象，就相当于 synchronize (Tets.class) static void bar() 当修饰非静态方法的是，锁定的当前的实例对象 this，就相当于 synchornize (this) void foo() 对于上面的 count++ 的问题，就可以使用互斥锁来解决问题。这样在一个线程操作 count 的时候加锁了，所以另一个线程是不能访问 count 变量的，再结合 Happens-Before 原则的管程锁定后原则，这样就不会出现并发的问题了。 12345678910public class Visible01 &#123; private long count; private synchronize void add10k()&#123; int idx = 10000; while (idx &gt; 0)&#123; count++; idx--; &#125; &#125;&#125; 但是上面的例子是一个被保护资源对应一个锁的情况，但是实际上一个锁是可以对应多个保护资源的。但是不能多个锁来保护一个资源。 当保护多个资源的时候，搜先需要区分这些资源之间是否存在联系。 保护多个没有关联的资源假设一个 Account 类中有两个成员变量，balance 和 password。取款 withdrew 和查看余额 getBalance 会访问balance，修改密码 updatePassword 和 查看密码 getPassword 会访问 password。而 balance 和 password 之家你是没有关系的。我们可以创建一个 blaLock 对象来保护 balance，创建一个 pwdLock 对象来保护 password。不同的资源使用不同的锁保护。 123456789101112131415161718192021public class Account &#123; private final Object balLock = new Object(); // 和余额相关的锁 private final Object pwdLock = new Object(); // 和密码相关的锁 private Integer balance; private Integer password; //取钱操作 public Integer withdrew(int num)&#123; synchronized (balLock)&#123; balance -= num; &#125; return balance; &#125; // 查看余额操作 public int getBalance()&#123; synchronized (balLock)&#123; return balance; &#125; &#125;&#125; 当然我们也可以使用一个锁来保护两个对象，例如我们可以通过对 this 加锁来保证这个实例中的所有资源。但是这样性能会很差，在 balance 被操作的时候，password 也是不可访问的。用不同的锁对受保护资源进行精细化管理，能够提升性能。这样的锁叫做细粒度锁。 保护有关联的多个资源在对多个资源的保护上这个问题就有点复杂了。例如银行转账业务，账户 A 减少 100 ，账户 B 增加 100 元。这两个账户之间就是有关联的。应该怎么实现这个问题呢 12345678910class Account&#123; private int balance; synchronize void transfer(Account target,int amt)&#123; if (this.balance &gt; amt)&#123; this.balance -= amt; target.balance += amt; &#125; &#125;&#125; 上面的代码似乎是可以解决问题的。但是这样确实错误的。原因在于，账户 A 调用方法向账户 B 转账。这个时候获得 A 这个锁，但是这个锁却不能保护 B 的余额。 下面我们具体分析一下，假设有A、B、C三个账户，余额都是200元，我们用两个线程分别执行两个转账操 作：账户A转给账户 B 100 元，账户B转给账户 C 100 元，最后我们期望的结果应该是账户A的余额是100元，账户 B 的余额是200元，账户C的余额是300元。 我们假设线程 1 执行账户 A 转账户 B 的操作，线程 2 执行账户 B 转账户 C 的操作。这两个线程分别在两颗 CPU 上 同时执行，那它们是互斥的吗？我们期望是，但实际上并不是。因为线程 1 锁定的是账户 A 的实例 （A.this），而线程 2 锁定的是账户B的实例（B.this），所以这两个线程可以同时进入临界区 transfer()。同 时进入临界区的结果是什么呢？线程 1 和线程 2 都会读到账户B的余额为 200，导致最终账户B的余额可能是 300（线程1后于线程2写B.balance，线程2写的B.balance值被线程1覆盖），可能是100（线程1先于线程2 写B.balance，线程1写的B.balance值被线程2覆盖），就是不可能是200。 那么怎么解决上面问题呢，只需要一个能覆盖所有受保护资源的锁就行了。稍微想一下，似乎 Account.class 类是符合我们的要求的，Account.class 是所有 Account 对象共享的，并且也是唯一的。 123456789101112class Account&#123; private int balance; void transfer(Account target,int amt)&#123; synchronize (Account.class) &#123; if (this.balance &gt; amt)&#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125;&#125; 但是这样做似乎有回到了上面的问题：这样的做法效率太低。两个账户之间的转账，只需锁住这两个账户，但是却锁住了 class ，导致同一时间只有一笔转账操作可以进行。 再想想似乎是有更好的解决方法 12345678910111213141516class Account&#123; private int balance; void transfer(Account target,int amt)&#123; //锁定转出账户 synchronize (this) &#123; //锁定转入账户 synchronize (target)&#123; if (this.balance &gt; amt)&#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125; &#125;&#125; 这看上去似乎很完美，提升了性能。但是却有可能会导致死锁。 死锁上面转账的代码是怎么发生死锁的呢？我们假设线程 T1 执行账户 A 转账户 B 的操作，账户 A.transfer(账户B)； 同时线程 T2 执行账户 B 转账户A的操作，账户 B.transfer(账户A)。当 T1 和 T2 同时执行完锁定转出账户的代码时，T1获 得了账户 A 的锁（对于 T1，this是账户 A），而 T2 获得了账户B的锁（对于 T2，this是账户 B）。之后 T1 和T2 在执行 锁定转入账户 的代码时，T1 试图获取账户B的锁时，发现账户B已经被锁定（被T2锁定），所以T1 开始等待； T2 则试图获取账户A的锁时，发现账户 A 已经被锁定（被 T1 锁定），所以 T2 也开始等待。于是 T1和 T2 会无期 限地等待下去，也就是我们所说的死锁了。 当一下四个条件都满足的时候就会发生死锁： 互斥 ：共享资源 X 和 Y 同一时间只能被一个线程占有 占有且等待：当 T1 占有 X 时，等待 Y 的时候，不放弃 X 持续等待：T1 持续等待 T2 释放 Y，T2 持续等待 T1 释放 X。 不可抢占：其他线程不能抢占获得 T1 的资源 X 只有上面的四个条件都成立的时候才会发生死锁，也就是只要破坏上面任意一个条件就可以解决死锁。其中互斥这个条件不能被破坏的。而其余三个都是可以破坏的条件。 占有且等待：在申请资源的时候，一次性申请说有的资源，这样就不存在等待的条件了。 不可抢占：在占有部分线程进一步申请其他资源的时候，如果申请不成功就放弃已经申请成功的资源。这样就不存在不可抢占。 持续等待：这个条件可以通过按序申请来解决。假定每个资源是线性有序的，每次申请资源的时候，先锁定小号的资源，再锁定大号的资源。这样就不存在持续等待的问题了。 解决占有且等待在转账业务中只要每次申请时同时申请两个账户，就可以解决这个问题 12345678910111213141516171819202122232425262728293031323334class Account&#123; int balance; Allocator allocator; // 应该为单例对象 public void transfer(int awt, Account target)&#123; while(!allocator.apply(this,target)); try&#123; synchronize (this)&#123; sychronize(target)&#123; // 执行转账操作 &#125; &#125; &#125;finally&#123; allocator.release(this,target); &#125; &#125;&#125;class Allocator&#123; ArrayList&lt;Account&gt; lock = new ArrayList&lt;Account&gt;; //一次申请所有的资源 public synchronize boolean apply(Account src, Account target)&#123; if (lock.contains(src) || lock.contains(target))&#123; return false; &#125;else&#123; lock.add(src); lock.add(target); return true; &#125; &#125; public synchronize void release(Account src,Account target)&#123; lock.remove(src); lock.remove(target); &#125;&#125; 但是这样的做法中在申请时使用了 while(!allocator.apply(this,target)); 。这样无疑增加了系统的开销。 解决不可抢占解决持续等待解决持续等待的方法就是，将共享资源按一定的规则，线性排序，每次从小的资源开始申请。 1234567891011121314151617181920class Account &#123; int balance; int id; public void transfer(int awt, Account target)&#123; Account left = this; Account right = target; if (this.id &gt; target.id)&#123; left = target; right = this; &#125; // 先锁定小的 synchronize (left)&#123; // 再锁定大的 sychronize(right)&#123; // 转账操作 &#125; &#125; &#125;&#125; 通知等待优化占用等待但是上面解决占用且等待的的方法并不是最优的方法。更为好的方式是使用 通知等待。 Java 中实现通知等待的方式一般使用 wait() notify() notifyAll() 这三个方法。其中 notify() 方法会随机的通知等待队列中的一个线程，而 notifyAll() 方法会通知所有的等待队列中的线程。由于使用 notify() 方法可以会出现永远不能通知到某个线程的情况，所以一般使用 notifyAll() 方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Account &#123; private Integer balance; public Account (int balance)&#123; this.balance = balance; &#125; // 转账操作 public void transfer(int awt, Account target)&#123; Allocator.getInstance().lock(this,target); this.balance -= awt; target.balance += awt; Allocator.getInstance().release(this,target); &#125; // 测试方法 public static void main(String[] args) throws InterruptedException &#123; Account src = new Account(10000); Account target = new Account(0); CountDownLatch countDownLatch = new CountDownLatch(1000); for (int i = 0; i &lt; 1000; i++) &#123; new Thread(() -&gt; &#123; src.transfer(1,target); countDownLatch.countDown(); &#125;).start(); &#125; countDownLatch.await(); System.out.println("src="+src.balance); System.out.println("target="+target.balance); &#125;&#125;// 单例的锁类class Allocator&#123; private Allocator()&#123;&#125; private static class Single&#123; private static final Allocator INSTANCE = new Allocator(); &#125; public static Allocator getInstance()&#123;return Single.INSTANCE;&#125; List list = new ArrayList(); public synchronized void lock(Account src, Account target)&#123; if (list.contains(src) || list.contains(target))&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; list.add(src); list.add(target); &#125; public synchronized void release(Account src, Account target)&#123; list.remove(src); list.remove(target); this.notifyAll(); &#125;&#125; 其中使用了 CountDownLatch 这个类，这个是用于多个线程同步的。构造函数需要传入一个 int 类型的参数初始化。每次调用 countDown() 方法将其中的计数器减一。调用 await() 方法会一直阻塞当前线程，直到计时器的值为0。 sleep() 和 wait() 方法都可以让当前线程挂起一段时间，之间有以下差异： sleep 方法是 Thread 类中的方法，wait 方法是 Object 类的方法。 sleep 方法会继续持有当前的锁，wait 方法会放弃当前的锁。 sleep 必须传入一个参数，指定醒来的时间。wait 方法不传递参数，需要 notify 方法来通知它醒来。 sleep 方法可以在任何地方使用。wait 方法只能在同步块或者同步方法中使用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java垃圾回收]]></title>
    <url>%2F2019%2F06%2F18%2FJava%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[如何确定垃圾Java 虚拟机内存中的程序计数器，虚拟机栈，本地方法栈这 3 个内存区域随线程而生，随线程而灭，是不需要过多考虑回收问题的。在 Java 堆里面存放着几乎所有的对象实例。垃圾回收器在回收之前，先要判断哪些对象是不能被任何途径使用的对象。 引用计数法给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加 1，当引用失效的时候，计数器就减 1。在任何计数器为 0 的对象就是不可能在被使用的。 这样的算法实现简单，判定效率高。但是主流的 Java 虚拟机没有使用这样的算法来判断。因为这样的算法很难解决对象直线循环引用的问题。 12345678910111213public class ReferenceCounting&#123; public Object instance = null; public static void testGC()&#123; ReferenceCounting objA = new ReferenceCounting(); ReferenceCounting objb = new ReferenceCounting(); objA.instance = objB; objB.instance = objA: objA = null; objB = null; &#125;&#125; 可达性分析算法一般时时通过可达性算法来实现判断对象是否能被引用的。 算法基本思想是：通过一系列称为 “root” 的对象作为起点，从这个节点开始搜索，搜索走过的路径称为引用链 （Reference Chain）,当一个对象不能通过饮用链到达 “root” 节点时，认为这个对象时不可达的。用图来说明，下面 object 5，object 6，object 7之间虽然相互之间有联系，但是是不可达的。 Java 中可作为 “root” 的对象包括以下几种： 虚拟机栈（栈帧中本地变量表）中的引用对象 方法区中静态属性引用的对象 方法区中常量引用的对象 本地方法栈中 native 方法引用的对象 GC 算法标记清楚算法复制算法标记整理算法分代收集算法Java 中四种引用类型]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>GC</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jvm内存区域]]></title>
    <url>%2F2019%2F06%2F17%2FJvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Java 虚拟机运行时数据区Java 虚拟机在执行 Java程序的过程中会把它所管理的内存分为若干个不同的数据区域。这些区域有着各自的用途，以及创建和销毁的时间。 Java 虚拟机所管理的内存一般包括以下几个运行时数据区域： 程序计数器程序计数器 (Program Counter Register) 是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。陈这类内存区域为“线程私有”的内存。 Java 虚拟机栈和程序计数器一样，Java 虚拟机栈 (Java virtual machine stack)也是 线程私有的，它的生命周期与线程相同。 每个方法执行的同时都会创建一个栈帧（stack frame）用于存储 局部变量表，操作数栈，动态链接，方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 -Xss:每个线程堆栈大小 本地方法栈本地方法栈（native method stack）与虚拟机栈的作用是类似的。他们之间的区别不过是，虚拟机栈执行 Java 方法服务，而本地栈为使用到的 native 方法服务。 Java 堆对大部分应用来说，Java 堆（Java heap）是 Java 虚拟机所管理的内存中最大的一块。 Java 堆是被 所有线程共享的一块内存区域。在虚拟机启动的时候创建。Java 堆唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 Java 堆是垃圾回收管理的主要区域。从内存回收的角度来看，现在的收集器基本采用粉黛收集算法，所以 Java 堆中可以细分为：新生代和老年代。 Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。 -Xms：堆最小值 -Xmx：堆最大值 方法区方法区（method area）和 Java 堆一样 是每个线程共享的内存区域。 它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。 运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。 class 文件中除了有类的版本，字段，方法，接口等描述信息以外，还有常量池（Constant Pool table），用于存放编译器生成的各种字面量和符号引用，这部分内容，在类加载以后进入方法区的运行时常量池中存放。 直接内存直接内存（direct memory）并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域。但是和部分内存也被频繁的使用。 在 JDK 1.4 中新加入了 NIO （new input/output）类，引入了一种基于通道（channel）与缓冲区（buffer）的 I/O 方式，它可以使用 native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这个快内存的引用进行操作。这样能在一些场景中显著的提高性能，因为避免了在 Java 堆和 native 堆中来回复制数据。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[List源码]]></title>
    <url>%2F2019%2F06%2F15%2FList%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[ArrayListArryList 的底层实现是数组队列。与 Java 中数组不同的是，它的容量能够动态的增长。 继承自 AbstractList, 实现了 List，RandomAccess，Cloneable，Serializable 这些接口。 在 ArrayList 中，很多地方使用了 System.arraycopy() 和 Arrays.copyOf() 这两个方法来复制数组。 比如在 add(int index, E element) 在指定位置插入元素的方法中就巧妙的使用了 arraycopy() 这个方法来复制数组。 12345678910111213/*** arraycopy() 的五个参数依次是:被复制的数组，被复制的坐标，复制到的数组，复制的坐标，复制多少个*/public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! //arraycopy()方法实现数组自己复制自己 //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量； System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; 在 toArray() 方法中又使用了 copyOf() 方法 1234567/*** copyOf() 方法的参数:被复制的数组，复制多少个*/public Object[] toArray() &#123; //elementData：要复制的数组；size：要复制的长度 return Arrays.copyOf(elementData, size);&#125; copyOf() 实际上是调用了 arraycopy() 方法的 arraycopy() 方法是需要实现创建一个目标数组，再将原数组拷贝至目标数组 copyOf() 方法不需要实现创建一个目标数组，在方法内部自动创建一个数组，并返回该数组. 另外需要注意的是： Java 中的length 属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性. Java 中的length()方法是针对字 符串String说的,如果想看这个字符串的长度则用到 length()这个方法. Java 中的size()方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看! LinkedListLinkedList 是一个实现了 List 接口和 Deque 的双端接口。底层实现是双向链表，支持高效的插入删除操作。 LinkedList 不是线程安全的 add方法12345678910111213141516171819public boolean add(E e) &#123; linkLast(e); return true;&#125;/*** 链接使e作为最后一个元素。*/void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode;//新建节点 if (l == null) first = newNode; else l.next = newNode;//指向后继元素也就是指向下一个元素 size++; modCount++;&#125; 根据索引位置得到数据的方法12345678910111213141516171819202122public E get(int index) &#123; //检查index范围是否在size之内 checkElementIndex(index); //调用Node(index)去找到index对应的node然后返回它的值 return node(index).item;&#125;Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); // 判断 当前位置是更靠近左边还是右边 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>JDK 源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8新特性]]></title>
    <url>%2F2019%2F05%2F27%2Fjava8%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[lambda 表达式在 Java 中一个方法的参数只能是一个类或者是基本类型，Java 不支持将函数作为方法的参数，也不支持一个方法的返回值是一个函数。在 JavaScript 中可以有一下的代码： 123function addOne(addNum)&#123; addNum();&#125; 在 Java 8 中新添加的 lambda 表达式中，允许 Java 进行函数式编程。在类似 JavaScript 中，lambda 表达式的类型是函数，但是在 Java 中，lambda 表达式是对象，必须依附于一类特别的对象类型 函数式接口(Functional Interface) 函数式接口Java 8 中新增了一个 Functional Interface 注解，对于一个函数式接口有着一下特性： 如果一个接口有且仅有一个抽象方法，那么这个接口可以称作是函数式接口。 在一个接口上声明 @Functional Interface 注解，那么编译器就会按照函数式接口来要求这个接口。 一个接口只有一个抽象方法，并且没有声明 @Functional Interface 注解，编译器会默认这个接口是函数式接口。 对于一个函数式接口有着三种实例化的方式，lambda 表达式，方法引用，构造器引用。 12Note that instances of functional interfaces can be created withlambda expressions, method references, or constructor references 另外对于函数式接口， Java 8 中允许一个接口中有实例方法。如果一个接口中继承了一个 Object 类中的方法，那么这个方法不会计算在仅有的抽象方法中。 123If an interface declares an abstract method overriding one of thepublic methods of &#123;@code java.lang.Object&#125;, that also does&lt;em&gt;not&lt;/em&gt; count toward the interface&apos;s abstract method count 比如，下面的接口虽然有着两个抽象方法，但是其中一个 toString 方法重写自 Object 类，所以这个接口也是符合函数式接口的： 123456@FunctionalInterfacepublic interface MyInterface &#123; void addOne(); String toString();&#125; 常用的函数式接口：Consumer，Fuction Consumer 接口接受一个参数，不返回结果，抽象方法 void accept(T t); Function 接口接受一个参数，返回一个结果，抽象方法 R apply(T t); 有两个默认方法，compose，addThen compose 方法接收一个 Function 的参数，返回一个 Function。返回的 Function 的 apply 方法的参数是接收 Function 执行 apply 方法后的结果。用于在当前 Function 之前执行一个 Function addThen 方法接受一个 Function 参数，返回一个 Function。返回的 Function 的 apply 方法参数是原本 Function 执行 apply 方法后的结果。用于在当前 Function 之前执行一个 Function BiFucntion 接口接受两个参数，返回一个结果，抽象方法 R apply(T t, U u); 有一个默认方法，addThen(Function&lt;? super R, &gt; extends V&gt; after); 返回值是 BiFunction Predicate 接口接收一个参数，返回一个 boolean 类型的结果，抽象方法 boolean test(T t); lambda 表达式入门一个 lambda 表达式的大致结构 1(arguments) -&gt; &#123;body&#125; 在左边的括号中填写参数，并以 -&gt; 作为分割，右边实现具体的操作。 一个 Lambda 表达式可以有零个或多个参数 参数的类型既可以明确声明，也可以根据上下文来推断。列如 (int a ) 与 (a) 效果相同。 所有的参数需要包含在箭头的左边圆括号内，参数与参数之间用逗号相隔。 空圆括号代表参数为空，不可省略 使用 Consumer 接口，传入一个参数，不返回结果本质上 lambda 是对于匿名内部类的简写，比如对于一个 List 的数据，实现循环通常可以有两中方式，一种是使用普通的 for 循环，另一种是使用增强的 for 循环。Java 8 中对于 List 类型，新增了一个 forEach 方法，方法的参数是需要传入一个 Consumer 接口的实例对象，可以使用匿名内部类来实现： 123456list.forEach(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer)&#123; System.out.println(integer); &#125;&#125;); 虽然这样可以实现遍历 list，但是似乎相比于一般的 for 循环更为复杂了。而在 Idea 中也会标记这个方法是可以使用 lambda 表达式来简化。点开 Consumer 接口，可以发现，这个接口是一个函数式接口。 1list.forEach(integer -&gt; System.out.println(integer)); 这样通过 lambda 表达式极大的简化了代码，也提高了可读性。 使用 Function 接口，传入一个参数，返回一个结果Map 接口中定义了 computeIfAbsent() 方法，用于存储，Map 中不存在传入的键时,对应的值。 使用 Function 接口，在 map 中不存在键为 “test” 的时候，在 Map 中存储一个数据。 1234567Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();int i = map.computeIfAbsent("test", new Function&lt;String,Integer&gt;()&#123; @Override public String apply(String s)&#123; return s.length(); &#125;&#125;); 使用 lambda 表达式 12Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();int i = map.computeIfAbsent("test", s -&gt; s,length()); 在 lambda 表达式出现以前，java 中都是值传递，对于一个方法，预先定义行为，调用的时候传入值。 12345public int addOne(int v)&#123; return v + 1;&#125;int res = addOne(1); 而 lambda 表达式的出现，允许 Java 进行行为传递。对于一个方法，将行为作为 ’参数‘ 传递进去。 对于上面加一的函数，lambda 表达的方法 12345public int add(int v, Function&lt;Integer,Integer&gt; function)&#123; return function.apply(v);&#125;int res = add(1, v -&gt; v +１)； 这样通过一个方法，可以实现多个不同的操作，只需要在调用时传入对应的操作。提升抽象层次，API 重用性更好，更加的灵活。]]></content>
      <tags>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netty基础]]></title>
    <url>%2F2019%2F05%2F26%2Fnetty%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[netty 可以做什么 可以作为 HTTP 服务器 ，类似 TomCat 等。但是 netty 相对于 Spring 等技术更为底层，处理速度也跟快，但是开发时间长。比如 netty 不支持：路由转发。 Socket 开发。底层数据的传输，HTTP 是基于 TCP 的应用层的协议。微服务。 支持长连接的开发，相对于 HTTP 1.0 的无状态和短连接。消息推送，在线聊天，服务端向客户端推送消息。 NIO 与 IOJava.io 中 最为重要的一个概念是 流（Stream）。一个流要么是输入流，要么是输出流。不可能同时又是输入又是输出。 在 java.io 中流大致可以分为节点流和过滤流。使用 装饰模式来增强一个节点流的功能。 Java.nio 中引入了3个核心概念:selector,Channel和Buffer。在 Java.nio 中是面向块（block）和缓冲区（buffer）编程的。 Java中的8种原生类型，除了 Boolean 都有各自对应的 buffer 类型，如 IntBuffer，LongBuffer等等。而 nio 中所有数据的读写都是通过 Buffer（由数组实现） 来实现的，Channel 则是可以读取或者写入 Buffer 的一个对象，永远不会出现直接向 Channel 中读写数据。 NIO 中 Buffer 类又三个 重要的属性，capacity，limit，position。 capacity：代表一个 Buffer 的容量大小，一旦指定以后就不能改变。 limit：代表 Buffer 中第一个不能读写数据的索引，代表当前索引位置是没有元素的，limit 永远不能大于 capacity。 position：代表当前读写元素的下一个可读写元素的索引。每次读写元素之后 position 会加一。position 是永远不能大于 limit的。 由于 Buffer 是支持读写操作的。所以在读写转换的时候需要调用 filp() 方法改变 Buffer 中的属性。在调用前后，capacity 是不会改变的；limit 改变为之前 position 的位置；position 变为 0。 对于 NIO 的具体使用如下： 123456789101112131415public stattic void main(String[] args)&#123; //申请 10 大小的 buffer IntBuffer buffer = IntBuffer.allocate(10); //向 buffer 中写入数据 for(int i = 0;i &lt; buffer.capacity();i++)&#123; int random = new SecureRandom().nextInt(20); buffer.put(random); &#125; //读写转换 buffer.filp(); //从 buffer 中读出数据 while(buffer.hasRemaining())&#123; System.out.println(buffer.get()); &#125;&#125; 上面的程序就会输出十个 0 - 20 的随机数。在读写之间通过调用 filp() 方法实现转换。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>netty</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类加载]]></title>
    <url>%2F2019%2F05%2F23%2F%E7%B1%BB%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[在 Java 代码中，类型(class, interface, enum 等 )、连接与初始化过程都是在程序运行期间完成的。 static int a = 1 加载：查找并加载类的二进制数据，最常用的一种，将在磁盘上编写的类型加载到内存中 连接： 验证：确保被加载类的正确性 准备：为类的静态变量分配内存，并初始化为默认值，这一步的时候 a 是 int 类型的，默认值 为 0 ， a = 0 解析：将类与类之间的关系确立（列如将一个类型的符号引用转换为直接引用） 初始化：对类中的静态变量赋予正确的初始值，这一步正确的初始值 1 赋值给 a， a = 1 类加载器 class loader ：将每个 Java 类型加载到内存中 在以下情况下，Java 虚拟机结束生命周期 执行了 System.exit() 方法 程序正常执行结束 程序正在执行过程中遇到了异常或者错误而异常终止 由于操作系统出现错误而导致 Java 虚拟机进程终止 初始化 所有的 Java 虚拟机实现必须在每个类或者接口被 Java 程序 首次主动使用 时才初始化。 主动使用： 创建类的实例 访问某个类或者接口的静态变量，或者是对这个静态变量赋值 调用类的静态方法 反射 (Class.forName(&quot;java.lang.String&quot;)) 初始化一个类的子类 虚拟机启动时被标记为启动类的类 Main方法 除了上述的方法以外，其他使用类的方法都视为对类的 被动使用 不会对类进行 初始化。 下面看一个例子代码演示： 定义一个父类，含有一个静态代码块，一个静态字段 1234567class Parent&#123; public static String str = "hello"; static&#123; System.out.println("Parent static block"); &#125;&#125; 再定义一个子类，同样含有一个静态代码快，一个静态字段 1234567class Child&#123; public static String str2 = "world"; static&#123; System.out.println("Child static block"); &#125;&#125; 对于下面的 main 方法执行结果是什么呢？ 123public static void main(String[] args)&#123; System.out.println(Child.str);&#125; 执行的结果是： 12Parent static blockhello 那么，再看看对于下面的 main 方法执行结果又是什么呢? 123public static void main(String[] args)&#123; System.out,println(Child.str2);&#125; 执行结果是： 123Parent static blockChild static blockworld 原来，对于静态字段来说，只有直接定义了该字段的类才会使用，所以对于第一次执行结果，只有父类的静态代码块得到了执行。 对于第二次执行结果，在初始化一个子类的时候，对于他的所有父类也视作主动使用，也会进行初始化。所以父类和子类的静态代码块都会得到执行。 但是修改一下 Parent 类的代码，将 str 设置为一个常量： 1234567class Parent&#123; public static final String str = "hello"; static &#123; System.out.println("Parent static block"); &#125;&#125; 这个时候执行下列 main 方法执行结果是什么呢？ 12345public class test&#123; public static void main (String[] args)&#123; System.out.println(Parent.str); &#125;&#125; 结果是只会打印 hello，并不会打印出 Parent 类的 static 块。 主要原因是:常量在编译阶段会存入到调用这个常量的方法所在的类的常量池中，本质上，调用类并没有直接引用到定义常量的类，因此定义常量的类并不会进行初始化 那么对于所有的常量都会被放到调用常量的类的常量池中吗？ 修改 Parent 类的代码，添加一个 String 类型的常量，只不过这个常量在编译期间是不可确定的。 123456789class Parent &#123; public static final String str = "hello"; public static final String ID = UUID.randomUUID().toString(); static &#123; System.out.println("parent static block"); &#125;&#125; 再在 main 方法中执行，结果是输出了随机 32 位的 ID 的同时也输出了 static 代码块的内容。 所以当一个常量的值并非编译期间可以确定的时候，这个常量并不会放到调用类的常量池中，当程序运行时，会导致主动使用这个常量所在的类，所以常量所在的类会进行初始化。 对于一下代码 12345678910111213141516171819202122232425public class Test &#123; public static void main(String[] args) &#123; Singleton singleton = Singleton.getSingleton(); System.out.println("num1 - " + singleton.num1); System.out.println("num2 - " + singleton.num2); &#125;&#125;class Singleton&#123; public static int num1; public static Singleton singleton = new Singleton(); private Singleton()&#123; num1++; num2++; System.out.println(num1); System.out.println(num2); &#125; public static int num2 = 0; public static Singleton getSingleton()&#123; return singleton; &#125;&#125; 执行结果是： 123411num1 - 1num2 - 0 为什么会产生这样的结果呢？ 是因为在 main 方法中是通过 getSingleton() 这个静态方法来获得 Singleton 的实例对象的。而首次调用一个类的静态方法会经过连接阶段的准备阶段，这个时候 num1 和 num2 是 int 类型的，所以都被初始化为 0。然后是通过 new 关键字获得一个实例对象，也就是初始化阶段。由类中定义的语句从上向下初始化，在构造方法中，num1 和 num2 都加一被改写为 1。而初始化阶段会把静态变量赋予正确的初始值，这个例子中 num2 正确的初始值是 0。所以最后结果 num1为 1，num2 为 0。但是构造方法内 num1 和 num2 都为 1。 类的加载 类的加载是指将类的 .class 文件中的二进制数据读入到内存中，将其放在运行是数据区 方法区 内，然后在内存中创建一个 Java.lang.class 对象，用来封装类在方法区内的数据结构。 加载 .class 文件的方式： 从本地系统中直接加载 通过网络下载 .class 文件 从 zip， jar 等归档文件中加载 .class 文件 从专有数据库中提取 .class 文件 将 Java 源文件动态编译为 .class 文件 虚拟机参数 -XX:+&lt;option&gt; ，表示开启 option 选项 -XX:-&lt;option&gt;， 表示关闭 option 选项 -XX:&lt;option&gt; = &lt;value&gt; ， 表示将 option 选项的值设置为 value 通过在 jvm 虚拟机配置中添加参数： -XX:+TraceClassLoading 可以打印出程序加载类的顺序 助记符 ldc 表示将 int，float，String 类型的常量值从常量池中推送至栈顶 bipush 表示将单字节 (-128 ~ 127) 的常量值推送至栈顶 sipush 表示将一个短整型常量值 (-32768 ~ 32767) 推送至栈顶 iconst_1 表示将 int 类型的 1 推送至栈顶，同样的还有 iconst_m1 ~ iconst_5 anewarray 表示创建一个引用类型（如类，接口 等）的数组，并将其引用值压入栈顶 newarray 表示创建一个指定的原始类型（如 int、float、char 等）的数组，并将其引用值压入栈顶 类的生命周期 加载：把二进制形式的 Java 类型读入 Java 虚拟机 验证：验证二进制形式的 Java 文件是否有错误 准备：为类变量分配内存，设置默认值。在初始化完成以前，类变量都没有初始化为正确的初始值 解析：在类常量池中寻找类，接口，字符和方法的符号引用，把这些符号引用替换为直接引用 初始化：为类变量赋予正确的初始值 类实例化： 为新的对象分配内存 为实例变量赋予默认值 为实例变量赋予正确的初始值 Java 编译器为每个编译的类至少生成一个实例初始化方法，对应类的构造方法。在 class 文件对于每个构造方法，编译器都生成一个 &lt;init&gt;方法 垃圾回收和对象终结 类加载器Java 虚拟机提供了以下 3 种类加载器： 启动类加载器（Bootstrap ClassLoader）：负责加载 JAVA_HOME\lib 目录的，或者是通过 -Xborclasspath参数指定路径中的，被虚拟机认可的（以文件名识别，如 jar 结尾的）类。 扩展类加载器（Extension ClassLoader）： 负责加载 JAVA_HOME\lib\ext 目录中，或者是通过 Java.ext.dirs 系统变量指定路径中类库。 应用程序类加载器（Application Class Loader）： 负责加载用户路径 ClassPath 上的类库 Java 虚拟机通过双亲委托模型来进行类的加载，当然也可以自定义类继承 java.lang.ClassLoader 实现自定义类加载器。 双亲委托：一个类加载器收到了类加载的请求，它首先自身不会尝试去加载这个类，而是把这个请求委托给父类去完成。只有当父类加载器无法完成这个加载请求的时候，它自身才会尝试加载。这样做的好处是，对于一个类保证了使用不同的类加载器都尽量获得同一个 Object 对象。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F04%2F15%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Java 中正则表达式Java 中也支持正则表达式。常用到的是以下内容： String 类的 split 方法。 java.util.regex 的 Pattern Matcher 对象 StringTokenizer 类（基本已经弃用） 表达式基础正则表达式中常用的匹配有一下： ‘.’ 匹配任意字符 ‘\d’ 匹配数组 [0-9] ‘\D’ 匹配非数字 [ ^0-9] ‘\w’ 词字符 [a-zA-Z0-9] ‘\W’ 非词字符 ‘\s’ 空白符（空格，tab，换行，换页，回车） ‘\S’ 非空白符 需要注意的是：在 Java 中，\ 代表着一个转译符，所以在正则表达式中想要表达 \s 的话需要在反斜杠前在加行一个反斜杠，就变成了 \\s。同理，如果想在正则表达式中表达一个普通的 \ 首先先要一个反斜杠来转译，同时这两个反斜杠，同样也需要转移，所以 Java 正则表达式中 \\\\ 代表着一个 \。 例子： n\\w+ 的匹配规则就是：匹配字母 n 以后跟着一个或多个词字符。 ‘n123’ 和 ‘next’ 都能匹配。而 ’n 123‘ 就无法匹配了。 量词正则表达式一般有两中模式来匹配文本： 贪婪型：贪婪的表达式会尽可能多的匹配。 勉强型：勉强型的表达式会尽可能少的匹配。 贪婪型 勉强型 如何匹配 X？ X？？ 一个或零个X X* X*? 零个或多个X X+ X+？ 一个或多个X X{n} X{n}？ 恰好n次X X{n，} X{n，}？ 至少n次 X{n，m} X{n，m}？ X至少n次，但是不超过m次 正则表达式通过通过圆括号来分组，以便能达到我们预期的结果，列如： abc+ 看起来似乎应该匹配，一个或多个 abc 序列。如果匹配的是字符串 abcabcabc ，实际上会获得 3 个匹配。这个表达式实际上匹配的是 ab，后面跟着 1 个或多个 C。 正确的匹配一个或多个 abc 正确的的表达式应该是： （abc）+ java 中使用正则表达式在 Java 程序中导入 java.util.regex 包。然后使用 static Pattern.compile() 方法来编译正则表达式。该方法返回一个 Pattern 对象。接下来，将想要匹配的字符串传入 Pattern 对象的 matcher(String s) 方法中，得到一个 Matcher 对象。 Matcher 中常用的方法： find() 返回是否还有能匹配的值，类似迭代器 hasNext() 方法 group() 组是用括号划分的正则表达式的匹配结果，没有传入代表当前的结果。组号 0 代表整个表达式。 start() 和 end() 代表匹配到的开始和结束。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis 基础]]></title>
    <url>%2F2019%2F04%2F14%2Fredis-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[redis 简介redis 是非关系型数据库（NoSql）的一种。是使用 key-value 的形式存储数据，常用于 缓存或者需要高速访问的情况. redis 支持 5 种数据类型： string（字符串） hash（哈希） list（列表） set（集合） zSet（有序集合） 同时 redis 支持 ROB，AOF 两种持久化方式。也支持事务和主从复制。 启动 redis 服务在正确安装了 redis 以后。进入 bin 目录，修改 redis.conf 文件，将 daemonize 属性改为 true： 通过 redis-server 指定使用哪个配置文件启动 redis 。 使用 redis-cli -p 指定 redis 服务的端口号。 再使用 ping 测试连通性。 StringString 类型，在 redis 中是一个键值对，通过使用。 set，get 来设置和获取对应 key 的值。 del 删除对应的值 keys * 获得所有 key expire key second 设置 key 的过期时间，以秒为单位 TTl key 返回 key 生存的秒数，返回 -1 代表当前 key 不过期 PERSIST key 设置 key 永不过期 Listlist 相当于是一个队列。 LPUSH 将一个或多个元素插入到 list 的头部 RPUSH 将一个或多个元素插入到 list 的尾部 LPOP 弹出list 头部的一个元素 LLEN 获取长度 LREM key count value 删除 list 中一定数目的 value 值 LRANGE key start stop 从指定位置开始打印列表，输出 0 -1 代表答应所有元素 Hashredis 中 Hash 也是 key-value，不过 value 中存储的也是一组 key-value。 HSET ,HGET 存储或得到一个 HMSET,HMGET 存储或得到多个 HGETALL 得到 HASH 中所有的键值对 HKEYS，HVALS 得到所有的键或者值 Set类似 list 但是不能添加重复的值。 SADD，SMENBERS 存储得到值 SREM 删除 set 中 value SCARD 返回 set 的长度 SMOVE key1 key2 value 将 key1 中的 value 移动到 key2 中 SPOP 随机出栈一个元素，SRANDMEMBER key Count 随机出栈多个元素 SDIFF 两个 set 的差集，SINTER 交集，SUNION 并集 ZSetZSet 就是有序集合，在 set 的基础上多了一个 score 来记录当前值的权重，根据权重来排序。 ZADD，ZRANGE（withscores） 存储得到值，是否带上权重 ZREVRANGE 反序排列 ZRANGEBYSCORE Min max 或者指定权重返回的值 ZRANK 根据 value 获得下标，ZSCORE 根据 value 获得对应的权重 事务redis 支持事务，下面是关于事务的命令： MULTI：开启事务 EXEC：结束执行事务 DISCARD：放弃当前事务 watch:监控一个 key 的值 unwatch：放弃对所有 key 的监控 正确执行事务： 在执行事务的过程中，如果出现一个命令不正确报错，会导致这次事务的所有操作失败回滚。： 在事务中，如果命令没有错误，但是在执行某条命令出错了，这个命令就不会执行成功，但是其他的命名会照常执行。这就是 redis 对事务的部分支持，不支持事务的回滚。 watch：加上一个乐观锁 悲观锁：在操作一个数据的时候认为别人也会操作这个数据，所以就锁住操作的对象。并发性差。 乐观锁：在操作一个数据的时候认为别人不会操作这个数据，不对数据加锁，引入 version 的机制来确保修改的数据不会丢失，每次上传的时候比较自己的 version 和数据真实的 version 。确保修改时候是在最新的数据上修改。 如果在 watch 监控了以后，数据被修改，这次失误就会执行失败，需要重新执行一次事务。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>noSlq</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap]]></title>
    <url>%2F2019%2F04%2F03%2FHashMap%2F</url>
    <content type="text"><![CDATA[概述HashMap 是由哈希表实现，是线程不安全的，允许 key 和 value 为 null。在遍历时是无序的。哈希表底层数据节后是数组，数组中每个节点存储着链表，链表中的每个节点 ，就是 HashMap 中存储的元素。当链表长度大于 8 时，会转化为红黑树，以提升查询、插入效率。 由于是由数组实现的，HashMap 在容量达到 threshold 以后会触发扩容函数 resize()。在扩容前后，数组的长度一定是 2 的次方。这样在根据 key 的 hash 值查找元素的时候，可以使用位运算代替取余操作，效率更高。 通过 key 的 hashCode() 和数组长度取余，来确定对应的元素放在数组的哪个位置。但是由于数组长度远远小于 hashCode() 的取值范围，而取余操作会忽略 hash 的高位。这样计算出得到 index 值相同的概率会很大，这种情况称为 hash 碰撞。扰动函数可以很好的减少 hash 碰撞的概率。 在 JDK 中用 hash &amp; (table.length - 1) 代替 hash % table.length，以提升效率。 每一个节点的 hash 值，是将 key 的 hashCode 和 value 的 hashCode 异或得到的。 源码HashMap 扩容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101final Node&lt;K,V&gt;[] resize() &#123; //存放旧的数组 Node&lt;K,V&gt;[] oldTab = table; //得到旧的数组的容量 int oldCap = (oldTab == null) ? 0 : oldTab.length; //旧数组的阈值 int oldThr = threshold; //初始化新的数组容量和阈值 int newCap, newThr = 0; //1. 如果旧的数组中存在节点 if (oldCap &gt; 0) &#123; //1.1 如果旧的数组容量已经达到上限 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; //设置阈值是 2 的 30-1 次方（最大值） threshold = Integer.MAX_VALUE; //数组已经到达最大容量，无法扩容，返回旧的数组。 return oldTab; &#125; //1.2 否则将新数组容量扩大为旧数组的两倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) // 新的阈值也扩大两倍 newThr = oldThr &lt;&lt; 1; // double threshold &#125; //2. 当前数组是空的，但是有阈值（代表指定了初始化的容量和阈值） else if (oldThr &gt; 0) newCap = oldThr;//设置新的容量是旧的阈值 //3. 当前数组是空的，并且没有指定阈值。代表初始化没有指定阈值和容量 else &#123; //指定新的容量是默认的容量 16 newCap = DEFAULT_INITIAL_CAPACITY; //指定新的阈值是默认的装填因子*默认的初始容量 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; //如果新的阈值是0，对应2.的情况，数组是空的但是初始化了阈值 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; //更新阈值 threshold = newThr; //根据新的容量创建一个数组 @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; //更新数组的引用 table = newTab; //如果扩容前数组是不为空的，需要将旧数组中的节点转移到新的数组中。 if (oldTab != null) &#123; //遍历旧的数组 for (int j = 0; j &lt; oldCap; ++j) &#123; //取出当前的节点 Node&lt;K,V&gt; e; //1. 当前节点不为空 if ((e = oldTab[j]) != null) &#123; //指定旧的数组引用为空 oldTab[j] = null; //当前链表中只有一个元素，没有发生哈希碰撞 if (e.next == null) //将这个链表节点放在新的数组中 newTab[e.hash &amp; (newCap - 1)] = e; //当前链表是红黑树，链表长度超过了8 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); //当前链表发生了哈希碰撞，并且没有转换为红黑树。依次将链表上的节点放在新数组中 else &#123; Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; //当前节点的下一个节点 Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; 上面的代码每一步都有详细的注释。只有最后一部分遍历数组，将所有的数组中链表依次放在新的数组中合适的位置的代表有点难以理解。下面就一步一步慢慢的分析： 12Node&lt;K,V&gt; loHead = null, loTail = null;Node&lt;K,V&gt; hiHead = null, hiTail = null; 定义了四个 Node 节点。从命名上可以知道是定义了 lo 和 hi 两个链表。这个四个 Node 节点分别指向 lo 和 hi 的头结点和尾节点。 接下来是一个 do-while 循环。可以看出来是在按排序遍历链表上的所有节点。 1234do &#123; next = e.next; ...&#125; while ((e = next) != null); 在循环中的 if-else 语句，是一个插入链表的实现 12345678910111213// 插入lo链表if (loTail == null) loHead = e;else loTail.next = e;loTail = e;// 插入hi链表if (hiTail == null) hiHead = e;else hiTail.next = e;hiTail = e; 上面的的代码大概就是创建了两个链表，然后遍历原链表上所有的节点，如果 (e.hash &amp; oldCap) == 0,就将节点放入 lo 链表中，否则就放入 hi 链表中。 12345678if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead;&#125;if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead;&#125; 最后这一段实现了： 如果 lo 链表非空，就将整个 lo 链表放在新 table 的 j 位置上。 如果 hi 链表非空，就将整个 hi 链表放在新 table 的 j + oldCap 位置上。 整个上面的代码实现了：就是将原来的连边拆分成为 lo 和 hi 两个链表。，并将这两个链表分别放在新 table 的 j 和 j + oldCap 的位置上。而将原 table 的拆分的依据就是：(e.hash &amp; oldCap) == 0. 关于 (e.hash &amp; oldCap) == 0 和 j 、 j + oldCap 虽然弄懂了是如何把旧数组的节点转换到新数组中，但是上述的拆分条件看起来确实很奇怪。 首先要明确三点： 数组的长度一定是 2 的整数次幂。 newCap 是 oldCap 的两倍。 hash 对数组大小取余 n - 1 &amp; hash 其实就是取 hash 的低 m 位。 首先假设数组的大小是 16 。那么 16 - 1 = 15 二进制表示为0000 1111。可以发现除了低 4 位，其他的位置都是 0，则 (16 - 1) &amp; hash 自然就是取 hash 值的低 4 位。假设它是 abcd 这样在数组扩容后，数组的大小是 32。这样原节点在新数组中的位置 index 就是 (32 - 1) &amp; hash,也就是取 hash 的低5位。那么对于同一个 Node，index 的值就只有两种情况：1abcd 或者 0abcd。其中 0abcd 和在旧数组中的 index 一样 abcd。而 1abcd = 0abcd + 10000 = 0abcd + oldCap。 所以虽然新旧 table 容量相差了两倍，但是同一个 key 在新旧 table 中的 index 要么一致，要么相差 oldCap 。而上述例子中新旧 index 是否一致就体现在 hash 值的第 4 位，通过 hash &amp; 0001 0000 = hash &amp; 16 = hash &amp; oldCap 这样的方式获得。如果是等于 0 就可以判断当前 key 对应的值在新旧 table 中是相同的，就放入 lo 链表中，否则就放在 hi 链表中。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2019%2F03%2F28%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[今天面试的时候被问到了单例模式，之前一直以为 static 关键字就是单例模式的实现。但实际上并不是。 什么是单例模式单例模式是 Java 中的设计模式之一。这个设计模式涉及到一个单一的类，这个类负责创建自己的对象（构造方式是 private），同时确保只有单个对象被创建。这个类提供一个访问其唯一对象的方式，可以直接访问，不需要实例化这个对象。 单例类只有一个实例对象 单例类必须自己创建这个实例对象 单例类为其他对象提供这个唯一的实例 单例模式实现方法懒汉式，线程不安全1234567891011puclic class Singleton&#123; private static Singleton instance; private Singleton() &#123;&#125; public static Singleton getInstance()&#123; if (instance == null)&#123; instance = new Singleton; &#125; return instance; &#125;&#125; 这段代码，实现了懒加载，但是有一个致命的缺点。在多线程并行调用 getInstance 方法时，就会创建多个实例。 懒汉式，线程安全为了解决上面代码线程不安全的问题，我们可以将 getInstance 方法设置为同步的（使用 Synchronized）。 1234567891011puclic class Singleton&#123; private static Singleton instance; private Singleton() &#123;&#125; public static synchronized Singleton getInstance()&#123; if (instance == null)&#123; instance = new Singleton; &#125; return instance; &#125;&#125; 这样虽然做到了线程安全，但是这样的方法效率很低。因为在任何时候只有一个线程能调用 getInstance 方法。但是同步的操作只需要在第一次调用的时候才需要，也就是在第一次实例对象被创建的时候是需要同步的，之后都可以直接判断是否已经创建了实例对象。这就引出了双重检测锁。 双重检测锁这种方式有两次检查 instance == null，一次在同步块外，一次在同步块内。因为可能多个线程一起进入同步块外的 if ，如果同步块内不做检查，就还是会创建多个实例对象。 12345678910private static Singleton getInstance()&#123; if (instance == null)&#123; synchronized (Singleton.class)&#123; if (instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; 事实上这段代码存在这一个问题 主要在于 instance = new Singleton() 这句，并并非是一个原子操作，事实上在 JVM 中这句话大概做了下面几件事： 给 instance 分配内存 调用 Singleton 的构造函数来初始化成员变量（创建实例对象） 将 instance 对象指向分配的内存空间 （执行完这步 instance 就是 非 null 的了） 在 JVM 的即时编译器中存在指令重排序的优化。也就是说 instance = new Singleton() 这句话不一定是按照 1-2-3这样顺序执行的，可能是 1-2-3 或者 1-3-2。如果是后者，则在 3 执行完毕、2 未指执行之前，当前线程被抢占了，这时 instance 已经是 非 null 的了（但是没有初始化），所以再调用 getInstance 得到的实际上是一个空对象，使用的时候自然就会报错。 解决这个问题只需要将 instance 对象声明成 volatile 就行了。 1private volatile static Singleton instance; //声明成 volatile volatile 可以禁止指令优化重排序。也就是在 volatile 变量的赋值操作后面会有一个内存屏障，读操作不会被重排序到内存屏障之前。比如上面的列子，取操作必须在执行完 1-2-3 或者 1-3-2 之后，存在上面 1-3 之后取到值的情况。 饿汉模式 static final这种方式非常简单，因为单例的实例被声明成了 static 和 final 的了，在第一次加载到内存中的时候就会被初始化，所以创建实例对象的本身是线程安全的。 12345678910public class Singleton&#123; //类加载时就初始化 private static final Singleton instance = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; 这种写法的缺点就是不是懒加载模式，单例会在加载类后一开始就初始化，即使客户端没有调用 getInstance 方法。这样的方式在一些场景中是无法使用的： Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance 之前必须调用每个方法设置参数给它。 静态内部类123456789public class Singleton()&#123; private static class SingleHolder&#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return SingleHolder.INSTANCE; &#125;&#125; 这种写法依然是线程安全的，由于 SingletonHolder 是私有的，除了getInstance 之外的方法么有颁发访问他，因此这中方式是懒加载的。多线程同时读取实例是不会进行同步，没有性能缺陷，不依赖 JDK 版本。 枚举 Enum123public enum EasySingleton&#123; INSTANCE;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie Session]]></title>
    <url>%2F2019%2F03%2F26%2FCookie-Session%2F</url>
    <content type="text"><![CDATA[CookieHttp 是无状态的连接，不对之前发生的请求和响应的状态进行管理。也就没有办法根据之前的状态对本次请求进行处理。 那么在登录的时候，即使登录请求已经成功响应。由于 Http 是无状态的，下一个请求也不记录登录的状态。就有两种解决方式： 每个跳转刷新页面都要再次登录。 每次在请求报文中添加参数来管理登录状态。 这时候就引入了Cookie来解决这一问题。Cookie 在请求和响应报文中添加 Cookie 信息来管理客户端状态。 客户端和服务端生成和保存 cookie 会经历一下步骤。 在客户端和服务端首次建立连接时，客户端向服务端发起请求。服务端生成 cookie 保存当前客户端信息，在响应时，将 cookie 一起返回给客户端，具体是通过响应报文中 Set-cookie 属性来通知客户端保存 cookie。 在之后客户端和服务端相互通讯时，客户端都会在请求报文中添加 cookie 。这样在服务端得到请求就可以知道是那个客户端在请求。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http和https]]></title>
    <url>%2F2019%2F03%2F24%2Fhttp%E5%92%8Chttps%2F</url>
    <content type="text"><![CDATA[什么是HTTP协议HTTP 协议全称是 Hyper Text Transfer Protocol，也就是超文本传输协议，位于 TCP/IP 四层模型中的应用层。 HTTP 协议是通过请求（request）响应（response）的方式，在客户端和服务端建立起通讯的。 由于 HTTP 协议的信息传输完全是以明文方式，不做任何加密，导致 HTTP 协议不够安全。 HTTP 协议是无状态的协议，是通过 cookie 或者 session 来管理会话信息。 什么是HTTPSHTTPS 就是加强版的 HTTP 协议。在 HTTP 层加入 SSL 层用于安全认证。 HTTPS 主要作用： 建立一个安全的信道，保证数据传输的安全性 确认网站的真实性质 HTTPS 是如何实现安全认证的首先我们看看为什么说 HTTP 协议是不安全的： 小明是客户端，小红是服务端。一天小明尝试向小红发送请求。 但是由于传送的是明文，这个信息在传输过程中很可能就会被中间人截取被篡改。 后来为了防止这样的情况出现，小明小红决定使用对称密钥加密信息，然后同样的使用密钥来解密信息。 这样是不是就是安全了呢？ 虽然在后续的通讯中都是传递的密文，但是首次约定密钥的时候还是用的明文传输。如果第一次通讯已经被拦截了，那么中间人知道了密钥，后续的密文，中间人同样可以解密并篡改。 然后想到可以使用非对称密钥，为密钥的传输做一层额外的保护。 在第一次建立通讯的时候，小红先把自己的公钥 Key1 发送给小明。 收到小红的公钥以后，小明生成一个对话密钥 Key2，并使用小红的公钥 Key1 来加密，发送给小红。小红接收到信息以后，利用自己的私钥解开 Key1，这样就得到了 Key2 。然后就可以使用 Key2 来加解密信息，进行通讯了。 这样就算中间人在一开始截取了含有 Key2 的密文也没有 key1 对应的密钥，不能解开密文得不到 key2。 但是如果中间人在首次小红把自己公钥告诉小明的时候就截取，并把小红的公钥 key1 换成自己的公钥 key3.而小明不知道其中的公钥已经不是小红的公钥 key1，便用了中间人的 key3 加密 key2。这样中间人就可以解密得到 key2。并使用小红的公钥 key1 加密发送给小红。 这样中间人同样掌握了会话密钥 key2。 这个时候我们引入一个第三方，一个权威证书除颁发中心 CA。那么这个证书又是什么呢： 在引入了证书以后的认证流程： 作为服务端的小红向证书颁发机构申请证书，把自己的公钥发送给证书颁发机构。 证书颁发机构利用自己的私钥来加密小红的公钥 key1。并通过服务器网址等信息生成一个证书签名，童颜证书签名也是用自己的私钥加密。将制作完成的证书发送给小红。 当有小明请求与小红通讯的时候不再是将自己的公钥 key1 发送给对方。而是将证书发送给对方。 小明收到证书以后，首先就是要验证证书的真实性。各大浏览器和操作系统都维护了所有的权威证书颁发机构的名称和公钥。所以小明只要知道是那个机构证书颁发的证书，就可以获得这个证书机构的公钥，并解密得到小红的公钥 key1 和证书签名。然后按照同样的签名规则生成证书签名，再对比两个证书签名。验证成功后，就可以放心的使用解密出的服务端的公钥加密对话密钥。与服务器建立通讯了。 有了证书，就算中间人，截取了小红发送的证书，换成自己的假证书，也无法通过认证。因为证书签名是由服务端网址等信息生成的，小明就算拿到了假证书证书签名也不能对比成功。 最后的公钥机构就是 HTTPS 解决安全问题的主题思想。HTTPS 在 HTTP 协议的基础上加了一层用于安全认证的 SSL 层。公钥机构认证就是在 SSL 层完成的。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 反射]]></title>
    <url>%2F2019%2F03%2F23%2FJava-%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[什么是反射反射（reflection）：通过Java反射机制可以在程序运行时动态的创建对象，并操作对象中的属性和方法。而这样的对象在编译期间是未知的。 Java 中反射提供以下功能： 运行时得到一个对象的所属类 运行时构造一个类的对象 运行时得到一个类中所有的方法和属性 运行时调用一个类中的任意方法 反射的运用反射的基本使用 获得Class对象有三种方式可以获得 Class 对象： 使用 Class 类的静态方法 forName： 1Class&lt;?&gt; aClass = Class.forName("java.lang.String"); 直接使用 .class 的方式获取： 1Class&lt;?&gt; sClass = String.class; 调用实例对象的 getClass() 方法： 12StringBuffer s = new StringBuffer();Class&lt;?&gt; sClass = s.getClass(); 判断是否是某个类的实例一般使用 instanceof 来判断是否是某个对象的实例。在 Class 类中也提供了 isInstance() 方法来判断是否是某个类的实例。 1boolean flag = sClass.isInstance(new StringBuffer()); 创建实例有两种方式来通过反射创建实例对象 使用 Class 类的 newInstance() 方法创建 1Object o = sClass.newInstance(); 先通过 Class 对象获得指定对象的 Constructor 对象，再通过 Constructor 的 newInstance() 方法来创建实例。这种方法可以指定构造器来生成新的实例对象。 1234567//获得 String 所对应的 Class 对象Class&lt;?&gt; sClass = String.class;//获取 String 类的构造器Constructor&lt;?&gt; constructor = sClass.getConstructor(String.class);//根据构造器创建实例对象Object o = constructor.newInstance("123");System.out.println(o); 获取方法获取某个 Class 对象的方法的集合，主要有以下的方法： getDeclareMethods 方法返回类或接口声明的所有方法，但不包括继承的方法。 1public Method[] getDecalrMethods() throws SecurityException getMethods 方法返回类的所有的 public 方法，包括继承的共用的方法。 1public Method[] getMethods() throws SecurityException getMethod 方法返回一个特定的方法，第一个参数是方法名称，后面的参数是方法应的参数的 class 。 1public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 下面举例说明下以上方法： 123456789101112131415161718192021222324252627282930313233public class SubClass&#123; private String subName; public int subAge; private void getPrivate()&#123; System.out.println("private sub"); &#125; public void getPublic(String s)&#123; System.out.println(s); &#125; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException &#123; //获得相应的 Class 对象 Class&lt;?&gt; aClass = Class.forName("Reflection.SubClass"); //获得所所有方法 Method[] declaredMethods = aClass.getDeclaredMethods(); //获得这个类所有的 public 方法，包括从所有父类继承的方法 Method[] methods = aClass.getMethods(); //获得指定的方法 Method getPublic = aClass.getMethod("getPublic", String.class); System.out.println("declaredMethods----"); for (Method m:declaredMethods)&#123; System.out.println(m); &#125; System.out.println("methods----"); for (Method m:methods)&#123; System.out.println(m); &#125; System.out.println("method----"); System.out.println(getPublic); &#125;&#125; 运行结果如下： 可以发现，在类中的 main 方法也是可以通过这样的方式来获得的。 获取构造器可以通过 getConstructor 方法的到 Constructor 的一个实例，并使用 newInstance 方法创建一个对象实例。 获取类的成员变量 getFiled 获得所有 public 修饰的的变量，包括从所有父类继承的。 getDeclaredFiled 获得这个类中所有的变量，不包括从父类继承的。 这两个方法类似 Method 的相关方法。 调用方法在获得了类中的一个方法以后，可以通过 invoke 方法来执行调用这个方法。 1public Object invoke(Object object, Object... args) 利用反射创建数组12345678public static void main(String[] args) throws ClassNotFoundException&#123; Class&lt;?&gt; aClass = Class.forName("java.lang.String"); Object array = Array.newInstance(aClass, 5); Array.set(array,0,"1"); Array.set(array,1,"2"); Array.set(array,2,"3"); System.out.println(Array.get(array,0)); &#125; 其中 Array 类是 Java.lang.reflect.Array 类，通过 newInstance() 创建对象，再通过 get，set 方法来添加获取数组中的值。 利用反射修改私有的属性先定义一个类 SuperClass 123public class SuperClass &#123; private String superName = "super";&#125; 在其他类中编写主方法来修改 SuperClass 中的私有属性 123456789101112131415public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123; //创建实例，获得 Class 对象 SuperClass superClass = new SuperClass(); Class&lt;?&gt; aClass = superClass.getClass(); //获得 SuperClass 类中名字为 superName 的变量 Field superName = aClass.getDeclaredField("superName"); if (superName != null)&#123; //设置访问权限，为 true 代表可以访问和修改私有对象 superName.setAccessible(true); //修改私有属性的值 superName.set(superClass,"sub"); //没有获得访问权限的话是不能获得私有属性的值 System.out.println(superName.get(superClass)); &#125; &#125; 最后程序运行结果是 : sub 。 通过这样的方式可以访问和修改私有的属性。 那么对于类中的常量也可以通过这样的方法来修改吗？ 修改 SuperClass 1234567public class SuperClass &#123; private final String FINAL_VALUE = "final"; public String getFINAL_VALUE() &#123; return FINAL_VALUE; &#125;&#125; 再修改测试类 123456789101112public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123; SuperClass superClass = new SuperClass(); Class&lt;?&gt; aClass = superClass.getClass(); Field FINAL_VALUE = aClass.getDeclaredField("FINAL_VALUE"); if (FINAL_VALUE != null)&#123; FINAL_VALUE.setAccessible(true); System.out.println("before:" + FINAL_VALUE.get(superClass)); FINAL_VALUE.set(superClass,"change"); System.out.println("after:" + FINAL_VALUE.get(superClass)); &#125; System.out.println("get:" + superClass.getFINAL_VALUE()); &#125; 程序运行结果： 可以看见在中间确实改变了常量的值，但是最后输出的时候却没有改变。这是因为由 final 修饰的成员属性，在 Java 编译时为了提升效率会把引用了常量的地方，带入常量。我们现在查看一下 SuperClass 类在编译以后的 .class 文件： 可以看见在编译过后，新增了一个无参的构造方法，并且在 getter 方法中，把常量的引用修改成了常量值。但是这种优化并不是对所有类型的常量都会优化，对于 int，double，long，boolean，String 这些基本类型是会进行优化的，但是对 Integer, Double, Long 这样的包装类型是不会优化的对于 Date, Object 这样的类型也是不会优化的。 知道了问题以后修改 SuperClass 1234567891011public class SuperClass &#123; private final String FINAL_VALUE; public SuperClass()&#123; FINAL_VALUE = "final"; &#125; public String getFINAL_VALUE() &#123; return FINAL_VALUE; &#125;&#125; 这样再来看编译以后的 SuperClass ： 这样再通过 getter 方法获得就是 FINAL_VALUE，而不是替换了过后的字符串。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 代理]]></title>
    <url>%2F2019%2F03%2F22%2FJava-%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[代理模式介绍代理的作用就是想增强一个目标类的方法，但是又不修改目标类，这样就可以用到代理。即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，达到扩展目标类方法的目的。 Java代理有三种方式：静态代理，动态代理，cglib代理。 静态代理这种代理方式需要目标列和代理类实现一样的接口。 UserDao （接口） 123public interface UserDao &#123; public void save();&#125; UserDaoImpl （目标类） 123456public class UserDaoImpl implements UserDao &#123; @Override public void save() &#123; System.out.println("保存数据"); &#125;&#125; UserDaoProxy （代理类） 12345678910111213141516171819public class UserDaoProxy implements UserDao &#123; private UserDaoImpl userDao; public UserDaoProxy(UserDaoImpl userDao)&#123; this.userDao = userDao; &#125; @Override public void save() &#123; System.out.println("开启事务"); userDao.save(); System.out.println("关闭事务"); &#125; public static void main(String[] args) &#123; UserDaoProxy proxy = new UserDaoProxy(new UserDaoImpl()); proxy.save(); &#125;&#125; 可以看见目标类和代理都实现了同一个接口. 最后执行的效果是： 动态代理 静态代理：是在程序编译以前就在代码中已经定义好的代理方式。也就就说Java编译以后的代理文件是一个class的文件 动态代理：代理是在程序运行是生成的。也就是Java编译完成后没有实际的class文件，而是在运行是动态生成的类字节码，并加载到JVM中。 Java实现动态代理的大致步骤如下： 1.定义一个目标类和公共接口 2.定义一个类，实现 InvocationHandler 接口。代理类调用任何方法都会经过这个调用处理器类。 3.生成代理对象，为代理对象指定（目标对象，目标对象实现的接口，调用处理器的实例）。由此看出一个代理对象对应一个目标对象，对应一个调用处理器实例。 Java实现动态代理涉及以下几个类 Java.lang.reflect.Proxy：这是生成代理对象所要使用的类，通过Proxy类生成的代理类都继承了Proxy类。Proxy类主要的方法为： 12//创建代理对象 static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 这个静态函数的第一个参数是类加载器对象，即哪个类加载器来加载这个代理类到JVM方法区（目标类的类加载器）。第二个参数是这个代理类所要实现的接口（一般为目标类实现的接口）。第三个参数是调用处理器的实例，用于指定代理类中具体实现了什么。 Java.lang.reflect.InvocationHandler：称他为“调用处理器”，是一个接口，我们动态生成的代理类需要自己定义一个类实现InvocationHandler接口。 InvocationHandler接口中是方法： 1invoke (Object proxy, Method method, Object[] args); 这个方法是在代理对象调用任何方法都会调用的。第一个参数是代理对象（标识哪个代理对象调用了方法）。第二个参数是Method（表示哪个方法被调用了）。第三个参数是调用方法的参数。 ProxyHandler（调用处理器） 123456789101112131415161718192021222324public class ProxyHandler implements InvocationHandler &#123; private UserDao userDao; public ProxyHandler(UserDao userDao)&#123; this.userDao = userDao; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("before"); Object result = method.invoke(userDao, args); System.out.println("after"); return result; &#125; public static void main(String[] args) &#123; UserDaoImpl userDao = new UserDaoImpl(); ProxyHandler proxy = new ProxyHandler(userDao); UserDao proxyUserDao (UserDao)Proxy.newProxyInstance( UserDaoImpl.class.getClassLoader(),UserDaoImpl.class.getInterfaces(), proxy); System.out.println(userDao.getClass()); System.out.println(proxyUserDao.getClass()); proxyUserDao.save(); &#125;&#125; 运行结果： 由打印结果可以看出来，Proxy.newProxyInstance返回的是一个代理对象。该对象有以下几个特点： 继承Proxy类。 public final 命名方式是$ProxyN，其中 N 会慢慢增加。 cglib代理先查看cglib源码的目录结构： 图中圈出的 Enhancer 和 MethodInterceptor 这两个两个类是cglib的核心。cglib生成代理类的思想就是生成一个新的类（Proxy），生成的代理类继承目标类，并对目标类方法实现一些前后操作。代理类直接继承自目标类，目标类就不用实现接口。 ProxyFactory （生成代理的工厂类）实现 MethodInterceptor接口，也可以使用匿名内部类方法 12345678910111213141516171819202122232425262728293031323334public class ProxyFactory implements MethodInterceptor &#123; private Object taget; public ProxyFactory()&#123;&#125; public ProxyFactory(Object o)&#123; taget = o; &#125; @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; System.out.println("before"); //执行目标类的方法 Object retunrValue = method.invoke(taget, args); //执行代理类的父类的方法，即执行目标类方法 methodProxy.invokeSuper(o,args); System.out.println("after"); return returValue; &#125; public Object getProxyInstance() &#123; Enhancer en = new Enhancer(); //设置代理类继承自那个类 en.setSuperclass(taget.getClass()); en.setCallback(this); return en.create(); &#125; public static void main(String[] args) &#123; UserDaoImpl userDao = new UserDaoImpl(); System.out.println(userDao.getClass()); UserDaoImpl proxy = (UserDaoImpl) new ProxyFactory(userDao).getProxyInstance(); System.out.println(proxy.getClass()); proxy.save(); &#125;&#125; 执行结果： 可以看到执行了两次目标类的方法。 总结 静态代理：就是代理类和目标类实现同一个接口，在代理类中调用目标类的方法，同时增强目标类的方法。这种实现代理的方式有很强的局限性。如果目标类的方法增加了，同样代理类中也要增加相应的方法来增强。 动态代理：相比于静态代理，动态代理解决了如果目标类增加新方法时，代理类也需要做出相应修改的问题。同时可以做到一个代理类可以代理不同的目标类。但是使用动态代理要求目标类需要实现接口，同时生成的代理类是继承自 Proxy。动态代理是不需要第三方库的支持。 cglib 代理：和动态代理最终实现的效果相似。但是生成的代理类是继承自目标类，同时不需要目标类实现接口。而 cglib 依赖于 cglib 类库。同时在 cglib 实现接口方法中提供了一个额外的参数， MethodProxy 代表着当前执行方法的代理，但是一般不会使用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试]]></title>
    <url>%2F2019%2F03%2F21%2F%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[第一次面试今天完成了人生中的第一次面试。前几天成都某公司来我们学校校招，我当时刚上完体育课，什么都没有准备就去笔试了。当然笔试成绩并没有通过。当时的我还以为我要是有了面试的机会，就有很大的几率能得到实习的机会。于是不甘心。所以当天晚上就找到在该公司工作的实验室学长寻求一个内推的机会。也很幸运的得到了一次面试的机会。 面试之前我还以为会问我很多有关项目的问题，但是实际上更多的问题是有关于JAVA，数据库，网络层协议这些更偏概念和基础的东西。下面将面试中遇到的问题整理如下： 项目中是如何实现会话认证的？前端发送过来一个请求，如何判断这个请求是否已经登录过？（HTTP协议的头部体现在哪里）Java中的反射机制，Java中的代理（cglib） Java 代理 Java 反射 Mysql数据库的实现方式，分别有什么区别？Sql语句的查询优化Http和Https的区别HTTP和HTTPS 子网和子网掩码上面的问题先挖个坑，随后逐一解决。 通过这次面试，我看见了自己的不足。面试以前我自认为自己还不错，但事实上我的基础很差，技术的了解范围也不多。很多东西都是大概了解，并不是完全掌握，这个侧面反映出我在平时的学习过程中，很多问题可能都知识了解一个皮毛，更深层次的东西并没有了解。 在这次面试的最后，面试官问过我一个星期能来公司几次。但是最后还是没有要我。可能是自己真的太菜了。哈哈。 单例模式单例模式 static 关键字get 方法和 post 方法HashMap]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试经历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2019%2F03%2F11%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[通用方法为了使排序算法更有适用性，所以不是简单的使用Int数组，而是使用Comparable。Java中的String，Integer，Byte类都实现了Comparable接口，所有这些类都可以使用这些排序算法。 交换数组的i，j索引位置的元素12345private static void exch(Comparable[] a,int i,int j)&#123; Comparable temp = a[i]; a[i] = a[j]; a[j] = a[i]&#125; 判断一个元素是否小于另一个元素 123private static boolean less(Comparable v,Comparable w)&#123; return v.compareTo(w) &lt; 0;&#125; 展示排序的结果123456private static void show(Comparable[] a)&#123; for (int i = 0; i &lt; a.length; i++) &#123; System.out.print(a[i]+" "); &#125; System.out.println(); &#125; 选择排序选择排序的算法就是每次选择数组中的最小（最大）的元素放在数组的最开始（最末端）。 123456789101112public static void selection(Comparable[] a)&#123; for (int i = 0;i &lt; a.length;i++)&#123; int min = i; //寻找当前最小的元素 for (int j = i+1;j &lt; a.length();j++)&#123; if (less(a[j],a[min])) min = j; &#125; //将当前最小的元素交换放在数组的前列 exch(a,i,min); &#125;&#125; 插入排序插入排序算法是从索引0开始，将每个索引的元素放在左侧合适的位置，使得当前索引的左侧永远是有序的。 123456789public static void insertion(Comparable[] a)&#123; //i索引的左侧都是有序的 for (int i = 0;i &lt; a.length;i++)&#123; //先判断j索引是否大于0，再判断当前j索引的元素是否小于j左侧的元素，成立就交换这两个元素 for (int j = i;j &gt; 0 &amp;&amp; less(a[j],a[j-1]);j--)&#123; exch(a,j,j-1); &#125; &#125;&#125; 希尔排序希尔排序是按照一定的步长，将数组的元素分成若干组，将这若干组中的元素排序，再取比上一个步长小的步长再一次排序，直到步长为1。在对分组元素排序的时候相当于是一个简化的插入排序。 步长的选择对希尔排序的性能影响很大。 时间复杂度小，没有使用额外的空间，排序算法的优先考虑 1234567891011121314public static void shell(Comparable[] a)&#123; //设置步长 int n = 1; while (n &lt; a.length/3) n = n*3+1; //按照步长分组进行插入排序，直到步长为1； while(n &gt;= 1)&#123; for (int i = 0;i &lt; a.length;i++)&#123; for (int j = i;j &gt;= n &amp;&amp; less(a[j],a[j-n]);j -= n)&#123; exch(a,j,j-n); &#125; &#125; n = n/3; &#125;&#125; 和普通的插入排序相比，希尔排序在步长为1的时候整个数组已经趋近于有序的了，在移动交换元素的时候使用的时间会比插入排序更少。但是希尔排序也是不稳定的。 归并排序归并排序的思想就是把一个数组分为左右两个部分，分别对这两个部分进行排序，再对这两个有序的左右部分合并。而利用递归的思想，可以把数组一直划分为左右两个部分，直到左右两个部分都只包含了一个元素（这个时候，左右两个部分都是有序的）再依次合并左右两个部分的数组。 利用递归思想划分数组12345678910111213141516171819202122//定义一个额外的数组，在合并左右两个数组的辅助private static Comparable[] aux;//外部调用的入口public static void sort (Comparable[] a)&#123; //初始化aux aux = new Comparable[a.length]; sort(a,0,a.length-1);&#125;//用递归的思想划分数组private static void sort(Comparable[] a,int lo,int hi)&#123; //递归结束的条件 if (lo &gt;= hi) return; int mid = lo + (hi-lo)/2; //将左半部分排序 sort(a,lo,mid); //将右半部分排序 sort(a,mid+1,hi); //合并左右两个部分 merge(a,lo,mid,hi);&#125; 合并两个有序的数组(合并a[lo..mid]和a[mid+1,hi])12345678910111213public static void merge(Comparable[] a,int lo,int mid,int hi)&#123; int i = lo,j = mid + 1;//i为左半部分起始索引，j为右半部分起始索引 //复制数组 for (int k = 0;k &lt; a.length;k++)&#123; aux[k] = a[k]; &#125; for (int k = lo;k &lt; hi;k++)&#123; if (i &gt; mid) a[k] = aux[j++];//左半部分用完，取右半部分 else if (j &gt; lo) a[k] = aux[i++];//右半部分用完，取左半部分 else if (less(a[j],a[i])) a[k] = aux[j++]; //右半部分小于左半部分的数，取右半部分 else a[k] = aux[i++]; //左半部分小于右半部分，取左半部分 &#125;&#125; 归并排序就是通过递归不断把数组分为左右两个部分，直到左右两个部分都只包含一个元素的时候，合并两个数组。算法的关键部分就是掌握合并数组是可能出现的4种情况。 快速排序快速排序是一种对随机数组排序较优的算法。 主要思路：先随机选取一个元素j，在数组的开始和结尾都各有一个指针（双指针）,在遍历到左边有一个元素lo大于j，右边有一个元素hi小于j，将这两个lo和hi交换位置。直到左右两个指针相遇。这个时候数组有一下的性质： 1.元素j已经处于排序以后的位置 2.元素j左边的元素都小于j 3.元素j右边的元素都大于j 采用递归的思想，对左右两边的元素进行上述操作。 递归操作1234567891011public static void sort(Comparable[] a)&#123; sort(a,0,a.length);&#125;private static void sort(Comparable[] a,int lo,int hi)&#123; //递归结束的条件 if (lo &gt;= hi) return; int j = partition(a,lo,hi); sort(a,lo,j-1); sort(a,j+1,hi);&#125; 选取元素，划分数组12345678910111213141516171819public static int partition(Comparable[] a,int lo,int hi)&#123; int i = lo,j = hi+1; //选取的随机元素 Comparable random = a[lo]; while(true)&#123; //通过左指针寻找左边大于random的元素 while(less(a[++i],random)) if(i == hi) break;//找不到就结束循环 //通过右指针寻找右边小于random的元素 while(less(random,a[--j])) if(j == lo) break;//找不到就结束循环 //如果左右两个指针已经相遇过了就不交换左右两边的元素。 if (i &gt;= j) break; //找到了左右两边的元素，进行交换 exch(a,i,j); &#125; //交换选取的随机元素到合适的位置 exch(a,j,lo); //返回已经排序好的元素的位置 return j;&#125; 快速排序算法的优化： 1、在切分到比较小的数组的时候，切换为插入排序，节省时间。 2、在一开始选取元素的时候，通过计算中位数，来确保划分数组时左右两边数组大小是接近的。 3、在对于有很多重复元素的数组的时候，划分数组分为大于、小于、等于这三个部分，而不只是换分为大于、小于两个部分，就可以减少对重复数据递排序的时间。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础（1）]]></title>
    <url>%2F2019%2F03%2F11%2FJava%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[什么是字节码？​ Java中引入了虚拟机的概念，即在机器和编译程序之前加入了一层抽象的虚拟机器。这台虚拟机器在任何平台上都提供给编译程序一个共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，再由解释器来将虚拟机中的代码转换为特定系统的机器能执行的代码。Java中，这种虚拟机能理解的代码就叫做字节码（即扩展名字为.class的文件）。不同的平台有着不同解释器，但是虚拟机是相同的。Java的源程序经过编译器编译后编程字节码，字节码有虚拟机解释执行，虚拟机将每一条要执行的字节码发送给解释器，解释器将其翻译为特定机器上的机器码执行。 ​ Java源代码–&gt;编译器–&gt;jvm可执行的Java字节码–&gt;jvm–&gt;jvm中的解释器–&gt;特定机器可以执行的二进制机器码。 采用字节码的最大好处是什么?​ Java通过使用字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。而且，字节码不转移对一种特定的机器，所以Java程序无需重新编译就可以在多种不同的机器上运行。 什么是Java虚拟机？​ 任何一种能够运行Java字节码的软件都可以看成是Java的虚拟机(jvm) 什么是Java程序的主类？应用程序和小程序的主类有什么不同？​ 一个程序中可以有多个类，但只有一个主类。在Java应用程序中，主类指的是包含main（）方法的类。在Java小程序中，这个主类是一个继承自系统类Japplet或者Applet的子类。应用程序中主类不一定要求是public的，但是Java小程序中必须要求主类是public的。主类是Java程序执行的入口。 什么是JDK？什么是JRE？​ JDK：是给开发者提供的开发工具箱。除了包括完整的JRE（Java runtime environment），Java运行环境，还包括了其他供开发者使用的工具包。 ​ JRE：普通用户就只用安装JRE来运行Java程序。而程序开发者必须安装JDK来编译调试程序。 接口和抽象类的区别是什么？​ 1.接口中所有的方法都是默认public的，所有方法在接口中都不能有实现，抽象类可以有非抽象的方法 ​ 2.接口中的实例变量默认是final的，抽象类中不一定。 ​ 3.一个类可以实现多个接口，但只能实现一个抽象方法。 ​ 4.一个类在实现接口时必须实现接口中所有的方法，而在实现抽象类时不一定。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[synchronized关键字]]></title>
    <url>%2F2019%2F02%2F25%2Fsynchronized%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[Synchronized关键简介Java并发编程中，Synchronized关键字是一种避免多线程同时操作对象中实例变量出现线程安全的方法。 Synchronized取得的锁都是对象锁，而不是把一段代码或者方法当做锁。 多个对象多个锁HasNum.java 12345678910111213141516171819public class HasNum &#123; private int num = 0; synchronized public void add(String userName)&#123; try &#123; if (userName.equals("a")) &#123; num = 100; System.out.println("a set over"); Thread.sleep(2000); &#125;else&#123; num = 200; System.out.println("b set over"); &#125; System.out.println(userName + "set num = "+ num); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ThreadA.java 123456789101112public class ThreadA extends Thread &#123; private HasNum hasNum; public ThreadA(HasNum hasNum)&#123; this.hasNum = hasNum; &#125; public void run()&#123; super.run(); hasNum.add("a"); &#125;&#125; ThreadB.java 123456789101112131415161718192021public class ThreadB extends Thread&#123; private HasNum hasNum; public ThreadB(HasNum hasNum)&#123; this.hasNum = hasNum; &#125; public void run()&#123; super.run(); hasNum.add("b"); &#125; public static void main(String[] args) &#123; HasNum hasNumA = new HasNum(); HasNum hasNumB = new HasNum(); ThreadA threadA = new ThreadA(hasNumA); ThreadB threadB = new ThreadB(hasNumB); threadA.start(); threadB.start(); &#125;&#125; 运行结果： aset num = 100要停顿一会才会执行。 上述主方法中创建了两个HasNum对象，Synchronized取得是对象锁,，所以产生了两个锁。在ThreadA执行到Thread.sleep(2000)的时候，线程睡眠，所以aset Num = 100 会停顿一会才能执行。 但是如果把主函数中改为： 1234567public static void main(String[] args) &#123; HasNum hasNum = new HasNum(); ThreadA threadA = new ThreadA(hasNum); threadA.start(); ThreadB threadB = new ThreadB(hasNum); threadB.start(); &#125; 运行结果： 这样就是两个线程共用一个对象，在ThreadA取得hasNum对象的时候，ThreadB在ThreadA执行完成以前都不能执行。同样的aset num = 100会等待一段时间执行。 Synchronized锁重入可重入锁的概念是：自己可以再次获得自己的内部锁。比如所一个线程的方法获得了一个对象的锁，这个时候对象的锁是还没有释放的，此时想要再次获得这个对象的锁还是可以获得的，这就是可重入锁。如果是不可重入锁的话，就会造成死锁。 Service.java 123456789101112131415public class Service &#123; synchronized public void service1()&#123; System.out.println("service1"); service2(); &#125; synchronized public void service2()&#123; System.out.println("service2"); service3(); &#125; synchronized public void service3()&#123; System.out.println("service3"); &#125;&#125; MyThread.java 12345678910111213public class MyThread extends Thread &#123; @Override public void run() &#123; super.run(); Service service = new Service(); service.service1(); &#125; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); myThread.start(); &#125;&#125; 运行结果： 另外可重入锁也支持在父子继承的关系中]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程基础]]></title>
    <url>%2F2019%2F02%2F24%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程和线程的简介进程进程是程序的一次执行过程，是系统运行程序的基本单位。一个程序的运行就是从一个进程创建开始的。在Windows中查看任务管理器，就可以看见当前Windows运行的进程（.exe文件） 线程线程和进程相似，但是线程是一个比进程更小的执行单位。一个进程的执行过程中可以产生多个线程。多个线程共享同一个内存空间和一组系统资源。所以系统在产生一个线程或者是在线程之间的切换，负担要比进程小得多，所以线程又被称为轻量级的进程。 几个重要概念同步异步同步和异步通常形容一次方法的调用。同步方法的调用，一旦开始，调用者必须在方法调用调用返回以后，才能执行后续的操作。异步方法的调用更像是一个消息的传递，一旦开始，方法调用就会立刻放回，调用者可以执行后续的操作。 并发（Concurrency）和并行（Parallelism）并发和并行是一个相似的概念。他们都可以表示多个任务同时执行。但是并行才是真正意义上的同时执行。并发，是多个任务交替执行。 多线程在单核CPU中是交替执行（并发）。多核CPU，每个CPU有自己的运算器，所以可以同时执行（并行）。 并行：两列队伍，两个咖啡机。 并发：两列队伍，一个咖啡机。 高并发（High Concurrency）高并发通常是指，通过设计保证系统能够同时并行处理很多请求。 高并发相关的常用指标：响应时间（response time），吞吐量（Throughput），每秒查询率QPS（Query Per Second），并发用户等。 临界区临界区是表示一种公共资源或者是共享数据，可以被多个线程使用。但是，同时间只能有一个线程可以使用它，一旦临界区的资源被占用，其他线程想要使用这个资源，就必须等待。在并行程序中，临界区资源是保护对象。 阻塞和非阻塞非阻塞指在不能立刻得到结果之前，该函数不会阻塞当前的线程，而会立刻返回，而阻塞与之相反。 使用多线程的三种常见方式前面的两种方式很少使用，一般使用的是第三种的线程池方式。 继承Thread类MyThread.java 1234567public class MyThread extends Thread&#123; @Override public void run()&#123; super.run(); System.out.println("MyThread"); &#125;&#125; Run.java 1234567public class Run&#123; public static void main(String[] args)&#123; MyThread myThread = new MyThread(); myThread.start(); System.out.println("运行结束")； &#125;&#125; 运行结果： 从上面的运行结果可以看出：线程是一个子任务，CPU以不确定的方式，或者是随机的时间来调用线程中的run方法。 实现Runnable接口推荐实现Runnable接口方式，因为Java单继承但是可以实现多个接口。 MyRunnable.java 123456public class MyThread implements Runnale&#123; @Override public void run()&#123; System.out.println("MyRunnable"); &#125;&#125; Run.java 12345678public class Run&#123; public static void main(String[] args)&#123; Runnable runnable = new MyRunnable(); Thread thread = new Thread(runnable); thread.start(); System.out.println("运行结束"); &#125;&#125; 运行结果： 使用线程池使用线程池的方式是最推荐的一种方式， 另外，在《阿里巴巴Java开发手册》在第一章第六节并发处理这一部分强调“线程资源必须通过线程池提供，不允许在应用中自行显示创建线程”。 实例变量和线程安全不共享数据的情况1234567891011121314151617181920212223242526public class MyThread extends Thread &#123; private int count = 5; public MyThread(String name)&#123; super(); this.setName(name); &#125; @Override public void run()&#123; super.run(); while (count &gt; 0)&#123; count--; System.out.println("由"+MyThread.currentThread().getName()+"计算，Count = "+count); &#125; &#125; public static void main(String[] args) &#123; MyThread a = new MyThread("a"); MyThread b = new MyThread("b"); MyThread c = new MyThread("c"); a.start(); b.start(); c.start(); &#125;&#125; 运行结果： 由此可以看出每个线程都有一个属于自己实例变量count，他们之间相互不影响。 共享数据的情况123456789101112131415161718192021222324public class SharedVariableThread extends Thread&#123; private int count = 5; @Override public void run()&#123; super.run(); while (count &gt; 0)&#123; count--; System.out.println("由"+MyThread.currentThread().getName()+"计算，Count = "+count); &#125; &#125; public static void main(String[] args) &#123; SharedVariableThread thread = new SharedVariableThread(); Thread a = new Thread(thread,"a"); Thread b = new Thread(thread,"b"); Thread c = new Thread(thread,"c"); Thread d = new Thread(thread,"d"); a.start(); b.start(); c.start(); d.start(); &#125;&#125; 运行结果： 可以发现这里已经出现了错误， 在大多数的JVM中，Count–的操作分为一下三步： 1.取得原有的Count的值 2.计算Count-1 3.对Count赋值 所以多个线程同时访问出现问题是难以避免的了。 那么有没有什么解决的方法呢 第一种是利用synchronize关键字（保证任意时刻只能有一个线程执行该方法） 第二种是利用AtomicInteger类。 一些常用的方法currentThread()返回当前正在执行的线程对象的引用。 getId()返回当前线程的标识符。 getName()返回当前线程的名称。 isAlive()测试这个线程是否处于活动的状态。 什么是活动状态 活动状态就是线程已经启动且尚未终止。线程处于正在运行或者准备运行的状态。 sleep()是当前正在执行的线程以指定的毫秒数”休眠”（暂时停止执行）。 interrupt()中断当前线程。 interrupted()和isInterrupted()interrupted()：测试当前线程是否是中断状态，执行后清除状态标志为false的线程。 isInterrupted():测试当前线程是否是中断状态，但是不清楚状态标志。 setName()更改当前线程的名称 isDeamon()测试当前线程是否是守护线程。 setDeamon(boolean on)将当前线程标记为deamon线程或用户线程。 join()很多情况下，主线程生成启动了子线程,如果子线程里需要进行大量的耗时的计算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用子线程的处理结果，也就是主线程需要等到子线程执行完成以后再结束，这个时候就要用到join()方法 join()的作用:“等待该线程结束”。 yield()yield()方法的作用就是放弃当前的CPU资源，将它让给其他的任务去占用CPU时间。但是放弃占用的时间不一定，可能很快就会重新获得CPU时间。 setPriority(int newPriority)更改当前线程的优先级。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP]]></title>
    <url>%2F2019%2F02%2F12%2FKMP%2F</url>
    <content type="text"><![CDATA[Kmp算法是一种查询字符串匹配的算法。比如说，有一个字符串”ABC CCACAC BACCACB”，想知道里面是否包含了另一个字符串”CCACB”？ ABC CCACCA BACCACB ​ CCACB 1. 先对对比两个字符串的第一个字母。第一个字母，A，C是不匹配的。所以继续向后移动一位。 2. 位移一位以后发现B,C也是不匹配的。所以再位移到和查找的字符串第一个字母匹配的地方。 3. 位移到与查找字符串第一个字母匹配的地方。接着再位移依次比较。 4. 直到出现有一个字母和搜索的字符不相同。 5. 这个时候，最容易想到的是，将整个查找词整个后移动一位，再从头比较，这样是可行的，但是效率过低。因为要把搜索查找过的词语再查找一次。 6.当比较到C，B不匹配的时候，其是知道前面的“CCAC”是匹配的，KMP算法的想法就是，利用这个已知信息，不把搜索的位置移动回到已经比较过的位置，这样就提高了效率。 这里就引入一个部分匹配的表： 首先，了解两个概念： “前缀”：指除了最后一个字符串以外，一个字符串的全部头部组合。 ”后缀“：指除了第一个字符以外，一个字符串的全部尾部组合。 以“CCACB”为例子： 12345- “C”的前缀和后缀都是空集，共有的元素是0- “CC”的前缀是[C]，后缀是[C],共有元素是1- “CCA”的前缀是[C,CC]，后缀是[C,CA],共元素是1- “CCAC”的前缀是[C,CC,CCA],后缀是[C,CA,CAC],共有元素是1- “CCACB”的前缀是[C,CC,CCA,CCAC],后缀是[C,CA,CAC,CACB],共有元素是1 这样的得到部分匹配表： 搜索词 C C A C B 部分匹配值 0 1 1 1 1 7. 在比较到C，B不匹配的时候。查询匹配表，可知最后一个匹配的字符“C”对应的部分匹配值是1。按照下面的公式计算出移动的位数： ​ 1移动位数 = 已匹配的字符数 - 对挺的部分匹配值 所以移动的位数是 4 - 1 = 3。 8.这样一直匹配就可以得到是否包含了这个字符串。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法]]></title>
    <url>%2F2019%2F01%2F06%2Fmarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、标题在想要设置为标题的文字前面加#来表示 一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。 示例： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题 二、字体 加粗 要加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 示例： 1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下： 这是加粗的文字 这是倾斜的文字 这是斜体加粗的文字 这是加删除线的文字 三、引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt; n个… 貌似可以一直加下去，但没神马卵用 示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线三个或者三个以上的 - 或者 * 都可以。 示例： 1234-------******** 效果如下： 可以看到，显示效果是一样的。 五、图片语法： 1234![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;) 效果如下： blockchain 上传本地图片直接点击导航栏的图片标志，选择图片即可 六、超链接语法： 12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) 效果如下： 简书 百度 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 1234&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;示例&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt; 七、列表 无序列表 语法： 无序列表用 - + * 任何一种都可以 12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表 语法： 数字加点 123451.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 效果如下： 1.列表内容 2.列表内容 3.列表内容 列表嵌套 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 八、表格语法： 1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例： 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 效果如下： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 九、代码语法： 单行代码：代码之间分别用一个反引号包起来 1`代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 12345(```) 代码... 代码... 代码...(```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 示例： 单行代码 1`create database hero;` 代码块 123456(```) function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;; &#125; fun();(```) 效果如下： 单行代码 create database hero; 代码块 1234function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;;&#125;fun();]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F01%2F06%2F%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[tags: 内部类 Java编程思想categories: Javaauthor: Jangtitle: 内部类date: 2019-01-06 11:26:00 什么是内部类把一个类的定义放在另一个类的定义内部，这个类就是内部类。 内部类可以访问外围类的所有成员。 在创建内部类实例对象时，首先要获得一个外部类的引用，然后通过.new的方式来创建：Out.Inner in = out.new Inner(); 成员内部类在一个类中以成员的形式定义一个内部类，就是最基础的内部类 1234567891011121314151617181920212223242526272829303132333435363738public class Outer&#123; private String a = "a"; public int i = 1; //内部类 class Inner&#123; private String b = "b"; public String c = "c"; public int getInt()&#123; return i; //内部类可以访问外部类的成员变量 &#125; private String getString()&#123; return a + b + c; &#125; &#125; public String getParam()&#123; Inner inner = new Inner(); inner.b = "bb"; inner.c = "cc"; return inner.getInt() + inner.getString(); &#125;&#125;//测试类class Test &#123; public static void main(String[] args) &#123; Outer outer = new Outer(); System.out.println(outer.getParam()); // 输出：1abbcc Outer.Inner oi = outer.new Inner(); oi.c = "ccc"; //oi.b = "bbb"; 编译失败 System.out.println(oi.getInt()); // 输出：1 //System.out.println(oi.getString()); 编译失败 &#125;&#125; 上面的代码就是一个最简单的内部类的使用。总接一下内部类的使用要点： 内部类可以访问外部内的所有变量 在外部类中使用内部类，需要通过 new 关键字创建一个实例对象。并且外部类可以访问到内部类所有的变量和方法。 在其他类中创建内部类对象需要使用这样的形式：OuterClass.InnerClass inner = new OuterClass.new InnerClass()。并且在其他类是不能访问内部类的四私有方法和对象的。 内部类通过 .this 的方式可以获得外部类的引用。 静态内部类在定义内部类的时候，用 static 关键字修饰 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Outer &#123; private int i = 1; public static String str = "str"; static class StaClass implements inter&#123; private String s = "s"; static int j = 2; static int getInt()&#123; //return i + j; return j; &#125; private String getString()&#123; return str + s; &#125; @Override public void inter() &#123; System.out.println("inter"); &#125; static class InStaClass&#123; int x = 4; static int y = 5; static int getInt()&#123; //return x; // x是非静态变量 不可以在静态方法中使用 return y; &#125; &#125; &#125; public inter getInter()&#123; return new StaClass(); &#125;&#125;interface inter&#123; void inter();&#125;class Test&#123; public static void main(String[] args) &#123; int a = Outer.StaClass.getInt(); //Outer.StaClass.getString(); // getString()为非静态方法，不能这样调用 int b = Outer.StaClass.InStaClass.getInt(); System.out.println(a + "----" + b); // 输出 2----5 //new Outer().new StaClass(); 编译失败 StaClass是静态的 new Outer().getInter().inter(); // 输出 inter &#125;&#125; 通过上面的代码，可以看出来静态内部类有以下特点： 静态内部类中可以定义静态的成员变量，也可以定义非静态的成员变量。 在静态内部类中只能访问外部类的静态变量和方法，不能访问非静态的变量和方法。 静态内部类的静态方法可以在其他类中通过，OuterClass.InnerClass.StaticMethod 这样的方式调用。 在其他类中，静态内部类是不能通过 new OuterClass.new InnerClass() 这样的方式获得。但是在外部类中可以通过 new 获得一个静态内部类的实例对象。 静态内部类中不能使用 .this 来获得外部类的引用。 局部内部类局部内部类是在一个方法或者任意作用域中定义的内部类。在有些情况下，需要一个类来辅助解决问题，但是又不希望这个类是公共可用的，这个时候可以用局部内部类来解决问题。 在方法中定义的类123456789101112131415161718192021public class Animal &#123; public Run howToRun()&#123; class RunWithLeg implements Run&#123; @Override public void runWith() &#123; System.out.println("Run with leg"); &#125; &#125; return new RunWithLeg(); //向上转型 &#125; public static void main(String[] args) &#123; Run animal = new Animal().howToRun(); animal.runWith(); &#125;&#125;interface Run&#123; void runWith();&#125; 这样在 Run 方法执行的时候，内部类才会存在，当 Run 方法执行结束。内部类就无法使用了。 在任意作用域中嵌入内部类1234567891011121314151617181920public class Add &#123; public static void main(String[] args) &#123; System.out.println(new Add().add(8)); &#125; public int add(int num)&#123; if (num &gt; 5)&#123; class Other&#123; private int i = 10; public int getNum() &#123; return i + num; &#125; &#125; return num + new Other().getNum(); &#125;else &#123; // new Other().getNum; 超过作用域 return 0; &#125; &#125;&#125; 这样的内部类只能在 (num &gt; 5) 这个作用域范围内生效。 匿名内部类匿名内部类主要适用于对于一个接口的隐式实现。 JDK1.8 以前如果在匿名内部类中引用外部的定义的对象，这对象必须是final的。 1234567891011121314151617181920class OuterClass &#123; public InnerClass getInnerClass(final int num,String str2)&#123; return new InnerClass()&#123; int number = num + 3; public int getNumber()&#123; return number; &#125; &#125;;//注意：分号不能省 &#125; public static void main(String[] args) &#123; OuterClass out = new OuterClass(); InnerClass inner = out.getInnerClass(2, "chengfan"); System.out.println(inner.getNumber()); &#125;&#125;interface InnerClass &#123; int getNumber();&#125; 匿名内部类的使用要点： 匿名内部类是没有访问修饰符的，且其中不能存在任何静态成员变量或者是静态方法。 匿名内部是不能包含构造器的，可以通过构造代码来模拟构造器。 在 Java8 中使用 lambda表达式 来代替大部分的内部类，可以让代码看上去更为简洁。]]></content>
  </entry>
</search>
